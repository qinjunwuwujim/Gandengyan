<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>干瞪眼 (最终版-v2)</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自定义样式 */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
            overscroll-behavior: none;
            background-color: #1F2937; /* gray-800 */
        }
        
        /* 隐藏滚动条 */
        ::-webkit-scrollbar { display: none; }

        /* 游戏界面 */
        #game-board {
            display: grid;
            grid-template-rows: 1fr 2fr 1fr; /* 上、中、下 */
            grid-template-columns: 1fr 3fr 1fr; /* 左、中、右 */
            height: 100vh;
            width: 100vw;
            padding: 1rem;
            box-sizing: border-box;
            gap: 1rem;
        }

        /* 玩家位置 */
        #player-area-top { grid-area: 1 / 2 / 2 / 3; flex-direction: column-reverse; } 
        #player-area-left { grid-area: 2 / 1 / 3 / 2; flex-direction: row-reverse; } 
        #player-area-right { grid-area: 2 / 3 / 3 / 4; } 
        #player-area-bottom { grid-area: 3 / 2 / 4 / 3; flex-direction: column; } 
        #table-area { grid-area: 2 / 2 / 3 / 3; }

        .player-area {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }
        
        .player-area.active {
            border-color: #FCD34D; /* yellow-300 */
            box-shadow: 0 0 15px rgba(252, 211, 77, 0.3);
        }

        .player-info {
            position: absolute;
            background: rgba(0,0,0,0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: white;
            z-index: 10;
        }

        /* 调整不同位置的信息显示 */
        #player-area-top .player-info { top: 0.5rem; } 
        #player-area-bottom .player-info { bottom: 0.5rem; } 
        #player-area-left .player-info { top: 0.5rem; }
        #player-area-right .player-info { top: 0.5rem; }

        .hand-container {
            display: flex;
            flex-wrap: wrap; /* 允许换行 */
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* 玩家自己的手牌区域 */
        #player-hand-area {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: auto; /* 手牌多时可滑动 */
            padding: 0.5rem;
        }
        #player-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0; /* 防止手牌被压缩 */
        }
        
        /* 卡片 */
        .card {
            width: 64px;
            height: 90px;
            border-radius: 6px;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 16px;
            font-weight: bold;
            position: relative;
            transition: all 0.2s ease-out;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden; 
        }
        .card.face-down {
            background-color: #3B82F6;
            background-image: linear-gradient(135deg, #60A5FA 25%, transparent 25%), linear-gradient(225deg, #60A5FA 25%, transparent 25%), linear-gradient(45deg, #60A5FA 25%, transparent 25%), linear-gradient(315deg, #60A5FA 25%, #3B82F6 25%);
            background-position: 8px 0, 8px 0, 0 0, 0 0;
            background-size: 16px 16px;
            background-repeat: repeat;
        }
        .card .rank { line-height: 1; padding: 4px; }
        .card .suit { font-size: 18px; line-height: 1; text-align: center; }
        .card .rank.bottom { padding: 4px; align-self: flex-end; transform: rotate(180deg); }
        .card[data-suit="♥"], .card[data-suit="♦"] { color: #EF4444; }
        .card[data-suit="♠"], .card[data-suit="♣"] { color: #1F2937; }
        
        .card.laizi {
            color: #1F2937; 
            border: 3px solid #FCD34D; 
            background-color: #FEF9C3; 
        }
        /* Joker SVG 样式 */
        .joker-svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }
         .joker-svg svg {
            width: 40px;
            height: 40px;
        }
        .joker-text {
            position: absolute;
            font-size: 10px;
            font-weight: bold;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            z-index: 2;
        }
        .joker-text-left { left: 5px; top: 25px; }
        .joker-text-right { right: 5px; top: 25px; transform: rotate(180deg); }
        
        .card[data-value="17"] { color: #EF4444; } 
        .card[data-value="17"] .joker-text { color: #EF4444; }
        .card[data-value="16"] { color: #1F2937; } 
        .card[data-value="16"] .joker-text { color: #1F2937; }


        /* 玩家自己的手牌 */
        #player-hand .card {
            cursor: pointer;
        }
        #player-hand .card.selected {
            transform: translateY(-15px);
            border: 3px solid #3B82F6; 
        }
        
        /* 桌面中央 (新) */
        #table-area {
            position: relative; 
            display: grid;
            grid-template-rows: 1fr auto 1fr;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            justify-items: center;
            gap: 4px; /* 牌堆和出牌区之间的间距 */
        }
        #bet-info {
            position: absolute;
            top: 0;
            background: rgba(0,0,0,0.5);
            padding: 0.25rem 0.75rem;
            border-radius: 99px;
            font-weight: bold;
            color: #FCD34D;
            z-index: 10;
        }
        
        #draw-pile-container {
            grid-area: 2 / 2 / 3 / 3; /* (新) 放在网格中心 */
            position: relative;
            width: 64px;
            height: 90px;
        }
        .deck-count {
            position: absolute;
            bottom: -20px;
            width: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.875rem;
            color: #D1D5DB;
            text-align: center;
        }
        
        /* (新) 玩家出牌区 */
        .last-play-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            min-height: 90px;
            min-width: 100px;
            gap: -20px;
            padding-left: 20px;
        }
        .last-play-area .card {
            margin-left: -20px;
            cursor: default;
        }
        
        /* (新) 定位出牌区到网格 */
        #last-play-area-top {
            grid-area: 1 / 2 / 2 / 3;
            align-content: flex-end; /* 牌堆叠在底部 */
        }
        #last-play-area-bottom {
            grid-area: 3 / 2 / 4 / 3;
            align-content: flex-start; /* 牌堆叠在顶部 */
        }
        #last-play-area-left {
            grid-area: 2 / 1 / 3 / 2;
            justify-content: flex-end;
        }
        #last-play-area-right {
            grid-area: 2 / 3 / 3 / 4;
            justify-content: flex-start;
        }
        
        
        /* 覆盖层 (弹窗) */
        .overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 50;
            color: #1F2937;
        }
        .modal {
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        .config-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
            text-align: center;
        }
        .config-label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
            text-align: left;
            font-size: 0.875rem;
        }
        
        /* 按钮 */
        .btn {
            padding: 10px 20px;
            font-weight: bold;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s;
            cursor: pointer;
        }
        .btn:disabled {
            background-color: #6B7280 !important;
            opacity: 0.7;
            cursor: not-allowed;
        }
        .btn-green { background-color: #10B981; color: white; }
        .btn-green:hover { background-color: #059669; }
        .btn-blue { background-color: #3B82F6; color: white; }
        .btn-blue:hover { background-color: #2563EB; }
        .btn-red { background-color: #EF4444; color: white; }
        .btn-red:hover { background-color: #DC2626; }
        
        /* 消息提示 */
        #message-area {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #FCD34D;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            z-index: 100;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        #message-area.show {
            opacity: 1;
        }
        
        /* 游戏内退出按钮 */
        #ingame-leave-btn {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 40;
        }
    </style>
</head>
<body class="text-white">

    <!-- 游戏主界面 (默认隐藏) -->
    <div id="game-board" class="hidden">
        
        <button id="ingame-leave-btn" class="btn btn-red">返回大厅</button>
        
        <div id="player-area-top" class="player-area hidden">
            <div id="player-info-top" class="player-info">玩家 2 (0 张)</div>
            <div id="player-hand-top" class="hand-container"></div>
            <!-- (旧) 出牌区已移走 -->
        </div>
        
        <div id="player-area-left" class="player-area hidden">
            <div id="player-info-left" class="player-info">玩家 1 (0 张)</div>
            <div id="player-hand-left" class="hand-container"></div>
            <!-- (旧) 出牌区已移走 -->
        </div>

        <!-- (新) table-area 现在包含所有出牌区和牌堆 -->
        <div id="table-area">
            <div id="bet-info">底分: <span id="base-bet-display">100</span></div>
            
            <div id="draw-pile-container">
                <div class="card face-down"></div>
                <div id="draw-pile-count" class="deck-count">剩余: 0</div>
            </div>
            
            <!-- (新) 4个出牌区 -->
            <div id="last-play-area-top" class="last-play-area"></div>
            <div id="last-play-area-bottom" class="last-play-area"></div>
            <div id="last-play-area-left" class="last-play-area"></div>
            <div id="last-play-area-right" class="last-play-area"></div>
        </div>

        <div id="player-area-right" class="player-area hidden">
            <div id="player-info-right" class="player-info">玩家 3 (0 张)</div>
            <div id="player-hand-right" class="hand-container"></div>
            <!-- (旧) 出牌区已移走 -->
        </div>
        
        <div id="player-area-bottom" class="player-area">
            <div id="player-info-bottom" class="player-info">你 (0 张)</div>
            <!-- (旧) 出牌区已移走 -->
            <div class="absolute bottom-2 right-2 flex gap-2 z-10">
                <button id="play-button" class="btn btn-green">出牌</button>
                <button id="pass-draw-button" class="btn btn-blue">摸牌 / 过</button>
            </div>
            <div id="player-hand-area">
                <div id="player-hand" class="hand-container">
                    <!-- 玩家的牌 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 加载界面 (默认显示) -->
    <div id="loading-screen" class="overlay">
        <div class="modal">
            <h2 class="text-2xl font-bold mb-4">正在连接...</h2>
            <p id="loading-status">正在连接到 Firebase 并进行身份验证...</p>
        </div>
    </div>
    
    <!-- 大厅界面 -->
    <div id="lobby-screen" class="overlay hidden">
        <div class="modal">
            <h2 class="text-2xl font-bold mb-4">干瞪眼 (在线版)</h2>
            <p class="mb-2">你的用户 ID: <strong id="user-id-display" class="text-xs break-all"></strong></p>
            
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="initial-score-input" class="config-label">初始积分:</label>
                    <input id="initial-score-input" type="number" value="10000" class="config-input">
                </div>
                <div>
                    <label for="base-bet-input" class="config-label">基础底分:</label>
                    <input id="base-bet-input" type="number" value="100" class="config-input">
                </div>
            </div>
            
            <div class="flex flex-col gap-4">
                <button id="create-room-btn" class="btn btn-green" disabled>创建房间</button>
                <hr>
                <input id="room-id-input" type="text" placeholder="输入房间 ID 或邀请链接" class="p-2 border rounded text-center">
                <button id="join-room-btn" class="btn btn-blue" disabled>加入房间</button>
            </div>
        </div>
    </div>
    
    <!-- 等待室界面 -->
    <div id="waiting-room-screen" class="overlay hidden">
        <div class="modal">
            <h2 class="text-xl font-bold mb-4">等待室</h2>
            <p id="waiting-room-prompt" class="mb-2">分享这个【邀请链接】给你的朋友:</p>
            <input id="room-id-display" type="text" readonly class="p-2 border rounded text-center w-full font-bold text-sm mb-4" onclick="this.select()">
            
            <h3 class="font-bold mb-2">已加入的玩家 (<span id="player-count">1</span>/4):</h3>
            <ul id="player-list" class="list-disc list-inside mb-4 text-left">
                <!-- 玩家列表 -->
            </ul>
            
            <button id="start-game-btn" class="btn btn-green hidden">开始游戏 (2-4 人)</button>
            <button id="leave-room-btn" class="btn btn-red mt-2">离开房间</button>
        </div>
    </div>

    <!-- 游戏结束弹窗 -->
    <div id="game-over-modal" class="overlay hidden">
        <div class="modal">
            <h2 id="game-over-title" class="text-3xl font-bold mb-4">游戏结束</h2>
            <p id="game-over-message" class="text-lg mb-6">玩家 1 赢了!</p>
            
            <div id="score-recap" class="mb-6 text-left">
                <!-- e.g. 玩家A: 10000 (+1000) -->
            </div>
            
            <button id="back-to-lobby-btn" class="btn btn-red">返回大厅</button>
            <button id="next-game-btn" class="btn btn-blue ml-2 hidden">下一局 (仅房主)</button>
        </div>
    </div>
    
    <!-- 癞子选择弹窗 -->
    <div id="laizi-choice-modal" class="overlay hidden">
        <div class="modal">
            <h2 class="text-2xl font-bold mb-4">请选择癞子组合</h2>
            <p class="mb-4">检测到多种出牌可能:</p>
            <div id="laizi-choice-buttons" class="flex flex-col gap-3">
                <!-- 按钮将在这里动态生成 -->
            </div>
        </div>
    </div>
    
    <!-- 消息提示框 -->
    <div id="message-area"></div>

    <!-- Firebase SDK -->
    <script type="module">
        // 导入 Firebase 模块
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction, writeBatch, arrayUnion, arrayRemove, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- 全局变量 ---
        let db, auth;
        let userId, appId;
        let currentRoomId = null;
        let localHand = [];
        let selectedIndices = [];
        let gameUnsubscribe = null;
        let handUnsubscribe = null;
        let myPlayerIndex = 0; 
        let hostFinishTimeout = null; 
        let currentRoomData = null; 
        let possibleLaiziPlays = []; 

        // --- UI 元素 ---
        const loadingScreen = document.getElementById('loading-screen');
        const loadingStatus = document.getElementById('loading-status');
        const lobbyScreen = document.getElementById('lobby-screen');
        const waitingRoomScreen = document.getElementById('waiting-room-screen');
        const gameBoard = document.getElementById('game-board');
        const gameOverModal = document.getElementById('game-over-modal');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const playButton = document.getElementById('play-button');
        const passDrawButton = document.getElementById('pass-draw-button');
        const initialScoreInput = document.getElementById('initial-score-input');
        const baseBetInput = document.getElementById('base-bet-input');
        const laiziChoiceModal = document.getElementById('laizi-choice-modal');
        const laiziChoiceButtons = document.getElementById('laizi-choice-buttons');

        // --- 牌型定义 ---
        const SUITS = ['♦', '♣', '♥', '♠']; // 方片(小) -> 黑桃(大)
        const SUIT_VALUES = { '♦': 1, '♣': 2, '♥': 3, '♠': 4 };
        const RANKS = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']; // 2 是癞子
        const RANK_VALUES = {};
        RANKS.forEach((rank, index) => { RANK_VALUES[rank] = index + 3; }); // 3=3 ... A=14
        
        const LAIZI_2_VALUE = 15; // 2
        const SMALL_JOKER_VALUE = 16; // 小王
        const BIG_JOKER_VALUE = 17; // 大王
        const LAIZI_VALUES = [LAIZI_2_VALUE, SMALL_JOKER_VALUE, BIG_JOKER_VALUE];
        
        const PLAY_TYPE = {
            INVALID: 'INVALID', SINGLE: 'SINGLE', PAIR: 'PAIR', TRIO: 'TRIO',
            FULL_HOUSE: 'FULL_HOUSE', 
            STRAIGHT: 'STRAIGHT', 
            CONSECUTIVE_PAIRS: 'CONSECUTIVE_PAIRS', 
            BOMB: 'BOMB',
            ROCKET: 'ROCKET' 
        };

        // --- 1. 初始化 Firebase ---
        
        async function initFirebase() {
            try {
                const firebaseConfig = {
                  apiKey: "AIzaSyCmSAI_ojtg7mEWQJ_hfZBWMTxy0nHh1nk",
                  authDomain: "gandengyan-32d4a.firebaseapp.com",
                  projectId: "gandengyan-32d4a",
                  storageBucket: "gandengyan-32d4a.firebasestorage.app",
                  messagingSenderId: "1088497241628",
                  appId: "1:1088497241628:web:f957fa04eb4152b26c59d9",
                  measurementId: "G-NNRVFGYEGZ"
                };
                
                appId = firebaseConfig.projectId; 

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, async (user) => {
                    if (!user) {
                        loadingStatus.textContent = "正在登录...";
                        try {
                            await signInAnonymously(auth);
                        } catch (authError) {
                            console.error("Auth Error:", authError);
                            throw new Error(`身份验证失败: ${authError.message}`);
                        }
                        return;
                    }
                    
                    userId = user.uid;
                    document.getElementById('user-id-display').textContent = userId;
                    createRoomBtn.disabled = false;
                    joinRoomBtn.disabled = false;

                    const params = new URLSearchParams(window.location.search);
                    const roomIdFromUrl = params.get('room');

                    if (roomIdFromUrl) {
                        showMessage(`正在自动加入房间 ${roomIdFromUrl}...`);
                        document.getElementById('room-id-input').value = roomIdFromUrl;
                        await autoJoinRoom(roomIdFromUrl);
                    } else {
                        showScreen('lobby');
                    }
                });
                
            } catch (error) {
                console.error("Firebase Init Error:", error);
                loadingScreen.innerHTML = `<div class="modal"><h2 class="text-2xl font-bold mb-4 text-red-600">连接失败</h2><p>${error.message}</p></div>`;
            }
        }
        
        function getRoomIdFromInput(input) {
            let roomId = input.trim().toUpperCase();
            try {
                const url = new URL(input);
                const roomParam = url.searchParams.get('room');
                if (roomParam) {
                    roomId = roomParam.toUpperCase();
                }
            } catch (e) {
                // Not a URL
            }
            return roomId;
        }

        async function autoJoinRoom(roomId) {
            joinRoomBtn.disabled = true; 
            
            const roomRef = doc(db, paths.room(roomId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) {
                        throw new Error("房间不存在 (来自链接)");
                    }
                    
                    const roomData = roomSnap.data();
                    if (roomData.status !== "waiting") {
                        if(roomData.status === "finished") {
                           // 允许加入
                        } else {
                           throw new Error("游戏已开始 (来自链接)");
                        }
                    }
                    
                    if (roomData.players.length >= 4 && !roomData.players.some(p => p.uid === userId)) {
                        throw new Error("房间已满 (来自链接)");
                    }
                    
                    if (!roomData.players.some(p => p.uid === userId)) {
                        const newPlayer = { 
                            uid: userId, 
                            name: `玩家 ${roomData.players.length + 1}`, 
                            cardCount: 0, 
                            score: roomData.initialScore || 10000 
                        };
                        transaction.update(roomRef, {
                            players: arrayUnion(newPlayer),
                            log: arrayUnion(`${newPlayer.name} 已加入。`)
                        });
                    }
                });

                await joinRoom(roomId); 
                
            } catch (error) {
                console.error("Auto-join Error:", error);
                showMessage("自动加入失败: " + error.message);
                joinRoomBtn.disabled = false;
                showScreen('lobby'); 
                window.history.pushState({}, '', window.location.pathname); 
            }
        }

        // --- 2. UI 屏幕管理 ---

        function showScreen(screenId) {
            loadingScreen.classList.add('hidden');
            lobbyScreen.classList.add('hidden');
            waitingRoomScreen.classList.add('hidden');
            gameBoard.classList.add('hidden');
            gameOverModal.classList.add('hidden');
            laiziChoiceModal.classList.add('hidden'); 
            
            if (screenId === 'waiting-room') {
                waitingRoomScreen.classList.remove('hidden');
                return;
            }

            const screenElement = document.getElementById(`${screenId}-screen`);
            if (screenElement) {
                screenElement.classList.remove('hidden');
            } else if (screenId === 'game-board') {
                 gameBoard.classList.remove('hidden');
            }
        }
        
        function showMessage(msg, duration = 2000) {
            const msgArea = document.getElementById('message-area');
            if (!msgArea) return; 
            msgArea.textContent = msg;
            msgArea.classList.add('show');
            setTimeout(() => msgArea.classList.remove('show'), duration);
        }

        // --- 3. 路径助手 ---
        const paths = {
            room: (roomId) => `/artifacts/${appId}/public/data/gandengyan-rooms/${roomId}`,
            hand: (roomId, uid) => `/artifacts/${appId}/public/data/gandengyan-hands/${roomId}-${uid}`
        };
        
        // --- 4. 大厅逻辑 (创建/加入) ---
        
        createRoomBtn.onclick = async () => {
            const btn = createRoomBtn;
            btn.disabled = true;
            btn.textContent = "创建中...";
            
            const initialScore = parseInt(initialScoreInput.value, 10) || 10000;
            const baseBet = parseInt(baseBetInput.value, 10) || 100;
            
            const roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            const roomRef = doc(db, paths.room(roomId));
            
            const initialRoomData = {
                roomId: roomId,
                hostId: userId,
                players: [{ 
                    uid: userId, 
                    name: `玩家 1`, 
                    cardCount: 0, 
                    score: initialScore 
                }], 
                status: "waiting", 
                drawPile: [],
                discardPile: [], 
                lastPlayedCards: [], 
                displayCards: [], 
                playerPlays: {}, 
                lastPlayerId: null, 
                currentPlay: null,
                currentPlayerIndex: 0,
                isNewRound: true,
                log: [`房间 ${roomId} 已创建。`],
                winner: null,
                gameNumber: 1, 
                bombCount: 0,  
                baseBet: baseBet,  
                initialScore: initialScore, 
                playHistory: [], 
                smallestCard: null, 
                smallestCardPlayerIndex: 0 
            };
            
            try {
                await setDoc(roomRef, initialRoomData);
                await joinRoom(roomId); 
            } catch (error) {
                console.error("Create Room Error:", error);
                showMessage("创建房间失败: " + error.message);
                btn.disabled = false;
            } finally {
                btn.textContent = "创建房间";
            }
        };

        joinRoomBtn.onclick = async () => {
            const inputVal = document.getElementById('room-id-input').value;
            const roomId = getRoomIdFromInput(inputVal); 
            
            if (!roomId) {
                 showMessage("请输入有效的房间 ID 或邀请链接");
                 return;
            }
            
            const btn = joinRoomBtn;
            btn.disabled = true;
            
            const roomRef = doc(db, paths.room(roomId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) {
                        throw new Error("房间不存在"); 
                    }
                    
                    const roomData = roomSnap.data();
                    if (roomData.status !== "waiting" && roomData.status !== "finished") {
                        throw new Error("游戏已开始或已结束");
                    }
                    
                    if (roomData.players.length >= 4 && !roomData.players.some(p => p.uid === userId)) {
                        throw new Error("房间已满");
                    }
                    
                    if (!roomData.players.some(p => p.uid === userId)) {
                        const newPlayer = { 
                            uid: userId, 
                            name: `玩家 ${roomData.players.length + 1}`, 
                            cardCount: 0,
                            score: roomData.initialScore || 10000 
                        };
                        transaction.update(roomRef, {
                            players: arrayUnion(newPlayer),
                            log: arrayUnion(`${newPlayer.name} 已加入。`)
                        });
                    }
                });

                await joinRoom(roomId); 
                
            } catch (error) {
                console.error("Join Room Error:", error);
                showMessage("加入失败: " + error.message);
                btn.disabled = false;
            }
        };

        // --- 5. 等待室逻辑 ---
        
        async function joinRoom(roomId) {
            currentRoomId = roomId;
            
            if (gameUnsubscribe) gameUnsubscribe();
            if (handUnsubscribe) handUnsubscribe();

            const roomRef = doc(db, paths.room(roomId));
            gameUnsubscribe = onSnapshot(roomRef, (docSnap) => {
                if (!docSnap.exists()) {
                    if (currentRoomId) { 
                        showMessage("房间不存在或已解散");
                        leaveRoom(false);
                    }
                    return;
                }
                currentRoomData = docSnap.data(); 
                renderGameState(currentRoomData);
            }, (error) => {
                console.error("Room subscription error:", error);
                leaveRoom(false);
                showMessage("房间连接错误: " + error.message);
            });
            
            const handRef = doc(db, paths.hand(roomId, userId));
            handUnsubscribe = onSnapshot(handRef, (docSnap) => {
                if (docSnap.exists()) {
                    localHand = docSnap.data().cards;
                    renderPlayerHand();
                } else {
                    localHand = []; 
                    renderPlayerHand();
                }
            });

            const roomSnap = await getDoc(roomRef);
            if(roomSnap.exists()) {
                const status = roomSnap.data().status;
                if(status === "playing" || status === "finishing") {
                    showScreen('game-board');
                } else if (status === "finished") {
                    showScreen('game-board'); 
                    renderGameState(roomSnap.data()); 
                } else {
                    showScreen('waiting-room');
                }
            } else {
                 showScreen('lobby');
            }
        }
        
        document.getElementById('leave-room-btn').onclick = () => leaveRoom(true);
        document.getElementById('ingame-leave-btn').onclick = () => leaveRoom(true);
        document.getElementById('back-to-lobby-btn').onclick = () => leaveRoom(false); 

        async function leaveRoom(updateDB) {
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null; 
            }
            if (handUnsubscribe) {
                handUnsubscribe();
                handUnsubscribe = null; 
            }
            if (hostFinishTimeout) {
                clearTimeout(hostFinishTimeout);
                hostFinishTimeout = null;
            }
            
            const roomId = currentRoomId;
            const uid = userId;
            
            currentRoomId = null;
            localHand = [];
            selectedIndices = [];
            currentRoomData = null; 

            if (updateDB && roomId && uid) {
                const roomRef = doc(db, paths.room(roomId));
                const handRef = doc(db, paths.hand(roomId, uid));
                
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomSnap = await transaction.get(roomRef);
                        if (!roomSnap.exists()) return;
                        
                        const roomData = roomSnap.data();
                        
                        const newPlayers = roomData.players.filter(p => p.uid !== uid);
                        
                        if (newPlayers.length === 0 || roomData.status === "finished") {
                            transaction.delete(roomRef);
                        } else {
                            let newHostId = roomData.hostId;
                            if (roomData.hostId === uid) {
                                newHostId = newPlayers[0].uid;
                            }
                            transaction.update(roomRef, {
                                players: newPlayers,
                                hostId: newHostId,
                                log: arrayUnion(`玩家 ${uid.substring(0,4)} 已离开。`)
                            });
                        }
                        transaction.delete(handRef);
                    });
                } catch (error) {
                    console.error("Leave Room Error:", error);
                }
            }
            
            showScreen('lobby');
            window.history.pushState({}, '', window.location.pathname);
        }

        // --- 6. 渲染游戏状态 (核心) ---
        
        function renderGameState(roomData) {
            if (!roomData || !currentRoomId) return;
            
            if (hostFinishTimeout) {
                clearTimeout(hostFinishTimeout);
                hostFinishTimeout = null;
            }

            if (roomData.status === "waiting") {
                showScreen('waiting-room');
                const inviteLink = `${window.location.origin}${window.location.pathname}?room=${roomData.roomId}`;
                document.getElementById('room-id-display').value = inviteLink;
                
                const playerList = document.getElementById('player-list');
                playerList.innerHTML = '';
                roomData.players.forEach(p => {
                    const li = document.createElement('li');
                    li.textContent = `${p.name} (积分: ${p.score}) ${p.uid === roomData.hostId ? '(房主)' : ''} ${p.uid === userId ? '(你)' : ''}`;
                    playerList.appendChild(li);
                });
                document.getElementById('player-count').textContent = roomData.players.length;
                
                const startBtn = document.getElementById('start-game-btn');
                if (roomData.hostId === userId && roomData.players.length >= 2) {
                    startBtn.classList.remove('hidden');
                    startBtn.textContent = `开始游戏 (${roomData.players.length} 人)`;
                } else {
                    startBtn.classList.add('hidden');
                }
                
            } else if (roomData.status === "playing" || roomData.status === "finishing") {
                if (window.location.search.includes('room=')) {
                    window.history.pushState({}, '', window.location.pathname);
                }
                showScreen('game-board');
                
                const numPlayers = roomData.players.length;
                myPlayerIndex = roomData.players.findIndex(p => p.uid === userId);
                if (myPlayerIndex === -1) {
                    // 旁观
                }
                
                const areas = [
                    { id: 'bottom', handEl: 'player-hand-area', infoEl: 'player-info-bottom', areaEl: 'player-area-bottom', playAreaEl: 'last-play-area-bottom' },
                    { id: 'left',   handEl: 'player-hand-left', infoEl: 'player-info-left', areaEl: 'player-area-left', playAreaEl: 'last-play-area-left' }, 
                    { id: 'top',    handEl: 'player-hand-top', infoEl: 'player-info-top', areaEl: 'player-area-top', playAreaEl: 'last-play-area-top' }, 
                    { id: 'right',  handEl: 'player-hand-right', infoEl: 'player-info-right', areaEl: 'player-area-right', playAreaEl: 'last-play-area-right' }
                ];
                
                areas.forEach(a => document.getElementById(a.areaEl).classList.add('hidden'));

                let displayMap = [];
                if (numPlayers === 2) {
                    displayMap[0] = areas[0]; // 我
                    displayMap[1] = areas[2]; // 对面
                } else if (numPlayers === 3) {
                    displayMap[0] = areas[0]; // 我
                    displayMap[1] = areas[1]; // 左
                    displayMap[2] = areas[3]; // 右
                } else {
                    displayMap[0] = areas[0];
                    displayMap[1] = areas[1];
                    displayMap[2] = areas[2];
                    displayMap[3] = areas[3];
                }
                
                // (新) 清空所有出牌区
                areas.forEach(a => {
                    const playAreaEl = document.getElementById(a.playAreaEl);
                    if (playAreaEl) playAreaEl.innerHTML = '';
                });

                for (let i = 0; i < numPlayers; i++) {
                    const player = roomData.players[i];
                    const relativeIndex = (i - myPlayerIndex + numPlayers) % numPlayers;
                    
                    const area = displayMap[relativeIndex];
                    if (!area) continue; 

                    const areaEl = document.getElementById(area.areaEl);
                    const infoEl = document.getElementById(area.infoEl);
                    const handEl = document.getElementById(area.handEl);
                    
                    areaEl.classList.remove('hidden'); 
                    infoEl.textContent = `${player.name} (${player.cardCount} 张) | ${player.score} 分`; 
                    
                    if (i === roomData.currentPlayerIndex) {
                        areaEl.classList.add('active');
                    } else {
                        areaEl.classList.remove('active');
                    }
                    
                    // (新) 渲染每个玩家的出牌区
                    const playAreaEl = document.getElementById(area.playAreaEl);
                    const playerPlay = roomData.playerPlays ? roomData.playerPlays[player.uid] : null;
                    if (playerPlay && playerPlay.displayCards) {
                        playerPlay.displayCards.forEach(card => {
                            playAreaEl.appendChild(createCardElement(card));
                        });
                    }

                    if (relativeIndex !== 0) { 
                        // (新) 堆叠手牌
                        const handContainer = document.getElementById(area.handEl);
                        handContainer.innerHTML = '';
                        if (player.cardCount > 0) {
                            handContainer.appendChild(createCardElement(null, true)); 
                        }
                    }
                }
                
                document.getElementById('draw-pile-count').textContent = `剩余: ${roomData.drawPile.length}`;
                const realBaseBet = (roomData.baseBet || 100) * Math.pow(2, roomData.bombCount || 0);
                document.getElementById('base-bet-display').textContent = realBaseBet; 
                
                // 按钮逻辑
                const isMyTurn = roomData.currentPlayerIndex === myPlayerIndex;
                const isNewRound = roomData.isNewRound;
                const isGameStart = (roomData.lastPlayerId === null); 
                
                if (roomData.status === "finishing") {
                    playButton.disabled = true;
                    passDrawButton.disabled = true;
                    const winnerName = roomData.players.find(p => p.uid === roomData.winner)?.name || "??";
                    showMessage(`${winnerName} 赢了! 5秒后结算...`, 4500);

                    if (roomData.hostId === userId) {
                        hostFinishTimeout = setTimeout(() => {
                            calculateAndFinishGame(roomData);
                        }, 5000); 
                    }
                    return; 
                }
                
                
                if (isMyTurn && isNewRound && !isGameStart) {
                    playButton.disabled = true;
                    passDrawButton.disabled = false;
                    
                    if (roomData.drawPile.length === 0 && roomData.discardPile.length === 0) {
                         passDrawButton.textContent = '无法摸牌 (跳过)';
                    } else {
                        passDrawButton.textContent = '摸牌 (新回合)';
                    }
                    
                } else if (isMyTurn && (!isNewRound || isGameStart)) {
                    playButton.disabled = false;
                    passDrawButton.disabled = false;
                    
                    if (roomData.drawPile.length === 0 && roomData.discardPile.length === 0) {
                        passDrawButton.textContent = '过 (Pass)';
                    } else {
                        passDrawButton.textContent = '摸牌 / 过';
                    }
                    
                    const isFreePlayAfterDraw = !isNewRound && roomData.currentPlay === null;
                    if (isFreePlayAfterDraw && !isGameStart) {
                        passDrawButton.disabled = true; 
                        showMessage("你必须出牌 (新回合)", 1500);
                    }

                } else {
                    playButton.disabled = true;
                    passDrawButton.disabled = true;
                }


            } else if (roomData.status === "finished") {
                const scoreRecapEl = document.getElementById('score-recap');
                scoreRecapEl.innerHTML = '';
                
                const oldScores = (roomData.oldPlayers || roomData.players).reduce((acc, p) => {
                   acc[p.uid] = p.score;
                   return acc;
                }, {});

                roomData.players.forEach(p => {
                    const oldScore = oldScores[p.uid] || p.score;
                    const scoreChange = p.score - oldScore;
                    const pEl = document.createElement('p');
                    
                    if (scoreChange > 0) {
                        pEl.textContent = `${p.name}: ${p.score} ( +${scoreChange} )`;
                        pEl.classList.add('font-bold', 'text-green-600');
                    } else if (scoreChange < 0) {
                        pEl.textContent = `${p.name}: ${p.score} ( ${scoreChange} )`;
                        pEl.classList.add('text-red-600');
                    } else {
                        pEl.textContent = `${p.name}: ${p.score} ( 0 )`;
                    }
                    scoreRecapEl.appendChild(pEl);
                });

                document.getElementById('game-over-title').textContent = roomData.winner === userId ? "恭喜你！" : "很遗憾...";
                const winnerName = roomData.players.find(p => p.uid === roomData.winner)?.name || "??";
                document.getElementById('game-over-message').textContent = `${winnerName} 赢得了游戏 (第 ${roomData.gameNumber || 1} 局)!`;
                gameOverModal.classList.remove('hidden');
                
                const nextGameBtn = document.getElementById('next-game-btn');
                if (roomData.hostId === userId) {
                    nextGameBtn.classList.remove('hidden');
                    nextGameBtn.onclick = () => startNextGame(roomData);
                } else {
                    nextGameBtn.classList.add('hidden');
                }
                
                // (修复) 保持订阅, 不再调用 joinRoom
            }
        }
        
        // --- 7. 渲染玩家手牌 (自己) ---
        
        function renderPlayerHand() {
            const playerHandArea = document.getElementById('player-hand');
            if (!playerHandArea) return; 
            
            playerHandArea.innerHTML = '';
            localHand.sort((a, b) => {
                const aIsLaizi = LAIZI_VALUES.includes(a.value);
                const bIsLaizi = LAIZI_VALUES.includes(b.value);
                
                if (aIsLaizi && !bIsLaizi) return 1;
                if (!aIsLaizi && bIsLaizi) return -1;

                const suitScoreA = a.suit ? SUIT_VALUES[a.suit] : (a.value === 16 ? 1 : 2);
                const suitScoreB = b.suit ? SUIT_VALUES[b.suit] : (b.value === 16 ? 1 : 2);
                
                return a.value - b.value || suitScoreA - suitScoreB;
            });
            
            localHand.forEach((card, index) => {
                const cardDiv = createCardElement(card);
                if (selectedIndices.includes(index)) {
                    cardDiv.classList.add('selected');
                }
                cardDiv.addEventListener('click', () => toggleCardSelection(index));
                playerHandArea.appendChild(cardDiv);
            });
            
            const infoBottom = document.getElementById('player-info-bottom');
            if (infoBottom && infoBottom.textContent) {
                const nameAndScore = infoBottom.textContent.split('(')[0] || '你';
                infoBottom.textContent = `${nameAndScore}(${localHand.length} 张)`;
            }
        }

        function createCardElement(card, isFaceDown = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            
            if (isFaceDown) {
                cardDiv.classList.add('face-down');
            } else {
                cardDiv.dataset.value = card.value;
                
                if (card.isLaiziSub) {
                    cardDiv.classList.add('laizi');
                } 
                else if (LAIZI_VALUES.includes(card.value)) {
                    cardDiv.classList.add('laizi');
                }

                if (card.value === BIG_JOKER_VALUE) {
                    // (新) SVG 大王
                    cardDiv.innerHTML = `
                        <div class="rank">J</div>
                        <div class="joker-text joker-text-left">JOKER</div>
                        <div class="joker-svg">
                            <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                                <path d="M50 10 C 40 10, 30 20, 30 30 S 40 50, 50 50 S 70 40, 70 30 S 60 10, 50 10 Z" fill="#FFD700"/>
                                <circle cx="40" cy="30" r="5" fill="#3B82F6"/>
                                <circle cx="60" cy="30" r="5" fill="#EF4444"/>
                                <path d="M40 40 Q 50 50, 60 40" stroke="#1F2937" stroke-width="3" fill="none"/>
                            </svg>
                        </div>
                        <div class="joker-text joker-text-right">JOKER</div>
                        <div class="rank bottom">J</div>`;
                } else if (card.value === SMALL_JOKER_VALUE) {
                    // (新) SVG 小王
                    cardDiv.innerHTML = `
                        <div class="rank">J</div>
                        <div class="joker-text joker-text-left">JOKER</div>
                        <div class="joker-svg">
                            <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                                <path d="M50 10 C 40 10, 30 20, 30 30 S 40 50, 50 50 S 70 40, 70 30 S 60 10, 50 10 Z" fill="#6B7280"/>
                                <circle cx="40" cy="30" r="5" fill="black"/>
                                <circle cx="60" cy="30" r="5" fill="black"/>
                                <path d="M40 40 Q 50 50, 60 40" stroke="#1F2937" stroke-width="3" fill="none"/>
                            </svg>
                        </div>
                        <div class="joker-text joker-text-right">JOKER</div>
                        <div class="rank bottom">J</div>`;
                } else {
                    cardDiv.dataset.suit = card.suit;
                    cardDiv.innerHTML = `
                        <div class="rank">${card.rank}</div>
                        <div class="suit">${card.suit}</div>
                        <div class="rank bottom">${card.rank}</div>
                    `;
                }
            }
            return cardDiv;
        }

        function toggleCardSelection(index) {
            const selIndex = selectedIndices.indexOf(index);
            if (selIndex > -1) {
                selectedIndices.splice(selIndex, 1);
            } else {
                selectedIndices.push(index);
            }
            renderPlayerHand();
        }
        
        // --- 8. 游戏逻辑 (开始/出牌/摸牌) ---
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        async function startNextGame(roomData) {
            if (roomData.hostId !== userId) return;
            
            const players = roomData.players;
            const numPlayers = players.length;

            let deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) { deck.push({ suit, rank, value: RANK_VALUES[rank] }); }
                deck.push({ suit, rank: '2', value: LAIZI_2_VALUE });
            }
            deck.push({ suit: 'Joker', rank: 'Small', value: SMALL_JOKER_VALUE });
            deck.push({ suit: 'Joker', rank: 'Big', value: BIG_JOKER_VALUE });
            
            deck = shuffleArray(deck);
            
            const hands = [];
            for (let i = 0; i < numPlayers; i++) hands.push([]);
            
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < numPlayers; j++) {
                    if (deck.length > 0) {
                        const card = deck.pop();
                        hands[j].push(card);
                    }
                }
            }
            
            let smallestValue = 99;
            let largestSuitScore = -1;
            let firstPlayerIndex = 0;
            let smallestCard = null;

            hands.forEach((hand) => {
                hand.forEach(card => {
                    if (!LAIZI_VALUES.includes(card.value) && card.value < smallestValue) {
                        smallestValue = card.value;
                    }
                });
            });

            hands.forEach((hand, playerIndex) => {
                hand.forEach(card => {
                    if (card.value === smallestValue) {
                        const suitScore = SUIT_VALUES[card.suit];
                        if (suitScore > largestSuitScore) {
                            largestSuitScore = suitScore;
                            firstPlayerIndex = playerIndex;
                            smallestCard = card;
                        }
                    }
                });
            });
            
            try {
                const batch = writeBatch(db);
                
                for (let i = 0; i < numPlayers; i++) {
                    const uid = players[i].uid;
                    const handRef = doc(db, paths.hand(currentRoomId, uid));
                    batch.set(handRef, { cards: hands[i] });
                }
                
                const updatedPlayers = players.map(p => ({ 
                    ...p, 
                    cardCount: 5 
                }));
                
                batch.update(doc(db, paths.room(currentRoomId)), {
                    status: "playing",
                    drawPile: deck,
                    discardPile: [],
                    players: updatedPlayers,
                    currentPlayerIndex: firstPlayerIndex, 
                    smallestCardPlayerIndex: firstPlayerIndex, 
                    smallestCard: smallestCard,
                    isNewRound: true,
                    lastPlayedCards: [],
                    displayCards: [], 
                    playerPlays: {}, // (新)
                    lastPlayerId: null, 
                    currentPlay: null,
                    log: arrayUnion(`第 ${ (roomData.gameNumber || 1) + 1 } 局游戏开始！`),
                    winner: null,
                    bombCount: 0,
                    baseBet: roomData.baseBet, 
                    initialScore: roomData.initialScore, 
                    playHistory: [], 
                    gameNumber: (roomData.gameNumber || 1) + 1,
                    oldPlayers: roomData.players // (新) 保存上一局的玩家数据（含积分）
                });
                
                await batch.commit();
                
            } catch (error) {
                console.error("Start Next Game Error:", error);
                showMessage("开始新游戏失败: " + error.message);
            }
        }
        
        async function calculateAndFinishGame(roomData) {
            if (roomData.hostId !== userId || roomData.status !== "finishing") {
                return; 
            }
            
            try {
                const baseBet = roomData.baseBet || 100;
                const winnerId = roomData.winner;
                
                const uniquePlayers = [...new Set(roomData.playHistory || [])];
                const isSpring = (uniquePlayers.length === 1 && uniquePlayers[0] === winnerId);
                
                const bombMultiplier = Math.pow(2, roomData.bombCount || 0);
                const springMultiplier = isSpring ? 2 : 1;
                const finalBet = baseBet * bombMultiplier * springMultiplier;
                
                if (isSpring) {
                    showMessage(`春天! 底分 x2`, 4000);
                }

                let totalGain = 0;
                const newScores = {};
                roomData.players.forEach(p => newScores[p.uid] = p.score); 

                roomData.players.forEach(p => {
                    if (p.uid !== winnerId) {
                        const loss = p.cardCount * finalBet;
                        newScores[p.uid] -= loss;
                        totalGain += loss;
                    }
                });
                
                newScores[winnerId] += totalGain;
                
                const updatedPlayers = roomData.players.map(p => ({ 
                    ...p, 
                    score: newScores[p.uid] 
                }));
                
                const roomRef = doc(db, paths.room(roomData.roomId));
                await updateDoc(roomRef, { 
                    status: "finished", 
                    players: updatedPlayers,
                    oldPlayers: roomData.players 
                });
                
            } catch (error) {
                console.error("Calculate Score Error:", error);
                const roomRef = doc(db, paths.room(roomData.roomId));
                await updateDoc(roomRef, { status: "finished" });
            }
        }

        document.getElementById('start-game-btn').onclick = async () => {
            if (!currentRoomId || !appId) return;
            
            const roomRef = doc(db, paths.room(currentRoomId));
            const roomSnap = await getDoc(roomRef);
            if (!roomSnap.exists()) return;
            const roomData = roomSnap.data();
            const players = roomData.players;
            const numPlayers = players.length;

            if (numPlayers < 2 || numPlayers > 4) {
                showMessage("必须有 2-4 名玩家才能开始。");
                return;
            }
            
            let deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) { deck.push({ suit, rank, value: RANK_VALUES[rank] }); }
                deck.push({ suit, rank: '2', value: LAIZI_2_VALUE });
            }
            deck.push({ suit: 'Joker', rank: 'Small', value: SMALL_JOKER_VALUE });
            deck.push({ suit: 'Joker', rank: 'Big', value: BIG_JOKER_VALUE });
            
            deck = shuffleArray(deck);
            
            const hands = [];
            for (let i = 0; i < numPlayers; i++) hands.push([]);
            
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < numPlayers; j++) {
                    if (deck.length > 0) {
                        const card = deck.pop();
                        hands[j].push(card);
                    }
                }
            }
            
            let smallestValue = 99;
            let largestSuitScore = -1;
            let firstPlayerIndex = 0;
            let smallestCard = null;

            hands.forEach((hand) => {
                hand.forEach(card => {
                    if (!LAIZI_VALUES.includes(card.value) && card.value < smallestValue) {
                        smallestValue = card.value;
                    }
                });
            });

            hands.forEach((hand, playerIndex) => {
                hand.forEach(card => {
                    if (card.value === smallestValue) {
                        const suitScore = SUIT_VALUES[card.suit];
                        if (suitScore > largestSuitScore) {
                            largestSuitScore = suitScore;
                            firstPlayerIndex = playerIndex;
                            smallestCard = card;
                        }
                    }
                });
            });
            
            try {
                const batch = writeBatch(db);
                
                for (let i = 0; i < numPlayers; i++) {
                    const uid = players[i].uid;
                    const handRef = doc(db, paths.hand(currentRoomId, uid));
                    batch.set(handRef, { cards: hands[i] });
                }
                
                const updatedPlayers = players.map(p => ({ ...p, cardCount: 5 }));
                
                batch.update(roomRef, {
                    status: "playing",
                    drawPile: deck,
                    discardPile: [], 
                    players: updatedPlayers,
                    currentPlayerIndex: firstPlayerIndex, 
                    smallestCardPlayerIndex: firstPlayerIndex, 
                    smallestCard: smallestCard, 
                    isNewRound: true,
                    lastPlayedCards: [],
                    displayCards: [], 
                    playerPlays: {}, // (新)
                    lastPlayerId: null, 
                    currentPlay: null,
                    log: arrayUnion(`游戏开始！${players[firstPlayerIndex].name} (有最小牌) 先出。`),
                    bombCount: 0, 
                    baseBet: roomData.baseBet, 
                    initialScore: roomData.initialScore, 
                    playHistory: [], 
                    gameNumber: 1, 
                });
                
                await batch.commit();
                
            } catch (error) {
                console.error("Start Game Error:", error);
                showMessage("开始游戏失败: " + error.message);
            }
        };

        // (新) 癞子选择弹窗
        function showLaiziChoice(plays, selectedCards, isGameStart, smallestCard) {
            possibleLaiziPlays = plays; // 缓存
            laiziChoiceButtons.innerHTML = '';
            
            plays.forEach((play, index) => {
                const btn = document.createElement('button');
                btn.className = 'btn btn-blue';
                
                // 检查是否包含最小牌 (如果是第一回合)
                if (isGameStart) {
                    const smallestCardId = (smallestCard.suit || '') + smallestCard.rank;
                    const displayCards = getDisplayCards(selectedCards, play);
                    const displayCardIds = displayCards.map(c => (c.suit || '') + c.rank);
                    
                    if (!displayCardIds.includes(smallestCardId)) {
                        // (新) 检查原始牌
                        const playedCardIds = selectedCards.map(c => (c.suit || '') + c.rank);
                        if (!playedCardIds.includes(smallestCardId)) {
                             btn.disabled = true; // 禁用不包含最小牌的选项
                        }
                    }
                }

                btn.textContent = `作为 ${getPlayDescription(play)} 出牌`;
                btn.onclick = () => {
                    executePlay(play, selectedCards);
                    laiziChoiceModal.classList.add('hidden');
                };
                laiziChoiceButtons.appendChild(btn);
            });
            
            laiziChoiceModal.classList.remove('hidden');
        }

        // (新) 出牌按钮重构
        playButton.onclick = async () => {
            if (selectedIndices.length === 0) {
                showMessage("请选择要出的牌");
                return;
            }
            if (!currentRoomData || !currentRoomId) return;
            
            playButton.disabled = true; 

            const selectedCards = selectedIndices.map(i => localHand[i]).sort((a, b) => a.value - b.value);
            
            const roomData = currentRoomData; // 使用缓存的数据
            const isGameStart = (roomData.lastPlayerId === null);
            const isFreePlay = isGameStart || roomData.isNewRound;
            
            if (isFreePlay && !isGameStart) {
                 showMessage("在新回合，你必须先摸牌！");
                 playButton.disabled = false;
                 return;
            }
            
            // (新) 查找所有可能的牌型
            const allPlays = findAllPossiblePlays(selectedCards);
            const validPlays = allPlays.filter(p => isValidPlay(p, roomData.currentPlay, isFreePlay));

            if (validPlays.length === 0) {
                showMessage("无效的出牌！");
                playButton.disabled = false; 
                return;
            }
            
            // (新) 检查第一回合是否包含最小牌
            if (isGameStart && roomData.currentPlayerIndex === roomData.smallestCardPlayerIndex) {
                const smallestCard = roomData.smallestCard;
                const smallestCardId = (smallestCard.suit || '') + smallestCard.rank;
                const playedCardIds = selectedCards.map(c => (c.suit || '') + c.rank);
                
                // 检查原始牌是否包含
                if (!playedCardIds.includes(smallestCardId)) {
                    // 检查所有可能的癞子组合是否包含
                     const validPlaysWithSmallest = validPlays.filter(play => {
                        const displayCards = getDisplayCards(selectedCards, play);
                        const displayCardIds = displayCards.map(c => (c.suit || '') + c.rank);
                        return displayCardIds.includes(smallestCardId);
                     });
                     
                     if (validPlaysWithSmallest.length === 0) {
                        showMessage(`第一回合必须包含你最小的牌 (${smallestCard.rank}${smallestCard.suit})！`);
                        playButton.disabled = false;
                        return;
                     }
                     
                     if (validPlaysWithSmallest.length === 1) {
                         executePlay(validPlaysWithSmallest[0], selectedCards);
                     } else {
                         showLaiziChoice(validPlaysWithSmallest, selectedCards, isGameStart, smallestCard);
                     }
                     return;
                }
            }

            if (validPlays.length === 1) {
                executePlay(validPlays[0], selectedCards);
            } else {
                // (新) 弹出癞子选择
                showLaiziChoice(validPlays, selectedCards, isGameStart, roomData.smallestCard);
            }
        };

        // (新) 真正的出牌执行函数
        async function executePlay(playInfo, selectedCards) {
            if (!currentRoomId || !appId) return;
            
            const playedCardIds = selectedCards.map(c => (c.suit || '') + c.rank); 
            const roomRef = doc(db, paths.room(currentRoomId));
            const handRef = doc(db, paths.hand(currentRoomId, userId));

            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    const handSnap = await transaction.get(handRef);
                    
                    if (!roomSnap.exists() || !handSnap.exists()) throw new Error("房间或手牌不存在");
                    
                    const roomData = roomSnap.data();
                    const handData = handSnap.data();
                    const numPlayers = roomData.players.length;
                    
                    if (roomData.status !== "playing") throw new Error("游戏未在进行");
                    if (roomData.players[roomData.currentPlayerIndex].uid !== userId) throw new Error("还没轮到你");
                    
                    const isGameStart = (roomData.lastPlayerId === null);
                    const isFreePlay = isGameStart || roomData.isNewRound;
                    
                    let finalPlayInfo = playInfo;
                    const lastPlay = roomData.currentPlay;

                    if (!isFreePlay && 
                        lastPlay && 
                        playInfo.type === PLAY_TYPE.SINGLE &&
                        LAIZI_VALUES.includes(playInfo.value) &&
                        lastPlay.type === PLAY_TYPE.SINGLE &&
                        lastPlay.value < BIG_JOKER_VALUE)
                    {
                        finalPlayInfo = {
                            ...playInfo, 
                            value: lastPlay.value + 1 
                        };
                    }
                    
                    const displayCards = getDisplayCards(selectedCards, finalPlayInfo);
                    
                    let idsToRemove = [...playedCardIds];
                    const newHand = handData.cards.filter(card => {
                        const cardId = (card.suit || '') + card.rank;
                        const indexToRemove = idsToRemove.indexOf(cardId);
                        
                        if (indexToRemove > -1) {
                            idsToRemove.splice(indexToRemove, 1);
                            return false; 
                        } else {
                            return true; 
                        }
                    });

                    if (idsToRemove.length > 0) {
                        console.error("手牌不同步! 没找到牌:", idsToRemove);
                        throw new Error("出牌失败 (手牌不同步)");
                    }
                    
                    let newStatus = roomData.status;
                    let winner = null;
                    if (newHand.length === 0) {
                        newStatus = "finishing"; 
                        winner = userId;
                    }
                    
                    let newBombCount = roomData.bombCount || 0;
                    if (playInfo.type === PLAY_TYPE.BOMB || playInfo.type === PLAY_TYPE.ROCKET) {
                        newBombCount++;
                    }
                    
                    transaction.set(handRef, { cards: newHand });
                    
                    const newPlayerIndex = (roomData.currentPlayerIndex + 1) % numPlayers;
                    const updatedPlayers = [...roomData.players];
                    updatedPlayers[myPlayerIndex].cardCount = newHand.length;
                    
                    // (新) 更新玩家出牌区
                    const newPlayerPlays = { ...roomData.playerPlays };
                    newPlayerPlays[userId] = { displayCards: displayCards };

                    transaction.update(roomRef, {
                        lastPlayedCards: selectedCards,
                        displayCards: displayCards, 
                        playerPlays: newPlayerPlays, // (新)
                        discardPile: arrayUnion(...selectedCards), 
                        currentPlay: finalPlayInfo, 
                        lastPlayerId: userId, 
                        playHistory: arrayUnion(userId), 
                        isNewRound: false, 
                        currentPlayerIndex: newPlayerIndex,
                        players: updatedPlayers,
                        status: newStatus,
                        winner: winner,
                        bombCount: newBombCount, 
                        log: arrayUnion(`${roomData.players[myPlayerIndex].name} 出牌了。`)
                    });
                });
                
                selectedIndices = []; 
                
            } catch (error) {
                console.error("Execute Play Error:", error);
                showMessage(error.message);
                playButton.disabled = false; 
            }
        }
        
        passDrawButton.onclick = async () => {
            if (!currentRoomId || !appId) return;
            passDrawButton.disabled = true; 
            
            const roomRef = doc(db, paths.room(currentRoomId));
            const handRef = doc(db, paths.hand(currentRoomId, userId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    const handSnap = await transaction.get(handRef);
                    
                    if (!roomSnap.exists() || !handSnap.exists()) throw new Error("房间或手牌不存在");
                    
                    const roomData = roomSnap.data();
                    const handData = handSnap.data();
                    const numPlayers = roomData.players.length;
                    
                    if (roomData.status !== "playing") throw new Error("游戏未在进行");
                    if (roomData.players[roomData.currentPlayerIndex].uid !== userId) throw new Error("还没轮到你");
                    
                    const newHand = [...handData.cards];
                    let newDrawPile = [...roomData.drawPile];
                    let newDiscardPile = [...roomData.discardPile];
                    let logMsg = "";
                    
                    let drawnCard = null;
                    if (newDrawPile.length > 0) {
                        drawnCard = newDrawPile.pop();
                    } else if (newDiscardPile.length > 0) {
                        newDrawPile = shuffleArray(newDiscardPile.filter(c => c)); 
                        newDiscardPile = [];
                        if (newDrawPile.length > 0) {
                           drawnCard = newDrawPile.pop();
                           logMsg = "(洗牌)";
                        }
                    }
                    
                    if (drawnCard) {
                        newHand.push(drawnCard);
                    }
                    
                    transaction.set(handRef, { cards: newHand });
                    const updatedPlayers = [...roomData.players];
                    updatedPlayers[myPlayerIndex].cardCount = newHand.length;
                    
                    if (roomData.isNewRound) {
                        logMsg = `${roomData.players[myPlayerIndex].name} 摸了一张牌 (新回合) ${logMsg}。`;
                        
                        transaction.update(roomRef, {
                            drawPile: newDrawPile,
                            discardPile: newDiscardPile,
                            players: updatedPlayers,
                            isNewRound: false, 
                            currentPlay: null, 
                            playerPlays: {}, // (新) 清空所有玩家的出牌
                            log: arrayUnion(logMsg)
                        });
                        
                    } else {
                        logMsg = `${roomData.players[myPlayerIndex].name} ${drawnCard ? '摸牌并' : ''}'过'了 ${logMsg}。`;
                        
                        const newPlayerIndex = (roomData.currentPlayerIndex + 1) % numPlayers;
                        
                        const nextPlayerUid = roomData.players[newPlayerIndex].uid;
                        const nextPlayerIsNewRound = (roomData.lastPlayerId !== null && nextPlayerUid === roomData.lastPlayerId);
                        
                        // (新) 当一圈人“过”时，清除出牌区
                        const newPlayerPlays = nextPlayerIsNewRound ? {} : { ...roomData.playerPlays };
                        // (新) 清除自己的出牌区
                        if (newPlayerPlays[userId]) {
                            delete newPlayerPlays[userId];
                        }

                        transaction.update(roomRef, {
                            drawPile: newDrawPile,
                            discardPile: newDiscardPile,
                            players: updatedPlayers,
                            currentPlayerIndex: newPlayerIndex,
                            isNewRound: nextPlayerIsNewRound, 
                            playerPlays: newPlayerPlays, // (新)
                            log: arrayUnion(logMsg)
                        });
                    }
                });
                
                selectedIndices = [];
                
            } catch (error) {
                console.error("Pass/Draw Error:", error);
                showMessage(error.message);
            }
        };
        
        // --- 9. 牌型验证 (含所有癞子) ---
        
        function getCardFromValue(value) {
            if (value === LAIZI_2_VALUE) return { suit: '♠', rank: '2', value: 15 };
            if (value === SMALL_JOKER_VALUE) return { suit: 'Joker', rank: 'Small', value: 16 };
            if (value === BIG_JOKER_VALUE) return { suit: 'Joker', rank: 'Big', value: 17 };
            const rank = RANKS.find(r => RANK_VALUES[r] === value);
            return { suit: '♦', rank: rank, value: value }; 
        }
        
        function getPlayDescription(playInfo) {
            if (!playInfo || !playInfo.type) return "无效";
            
            const cards = playInfo.cards || [];
            const displayCards = getDisplayCards(cards, playInfo);
            const firstCard = displayCards[0] || {};
            
            switch(playInfo.type) {
                case PLAY_TYPE.ROCKET: return "王炸";
                case PLAY_TYPE.BOMB: return `炸弹 ${firstCard.rank || ''}`;
                case PLAY_TYPE.SINGLE: return `单张 ${firstCard.rank || ''}`;
                case PLAY_TYPE.PAIR: return `对子 ${firstCard.rank || ''}`;
                case PLAY_TYPE.TRIO: return `三条 ${firstCard.rank || ''}`;
                case PLAY_TYPE.FULL_HOUSE: 
                    const trioRank = getCardFromValue(playInfo.value).rank;
                    const pairRank = displayCards.find(c => c.value !== playInfo.value)?.rank || 'X';
                    return `三带二 ${trioRank}${trioRank}${trioRank} + ${pairRank}${pairRank}`;
                case PLAY_TYPE.STRAIGHT:
                    const endCard = displayCards[displayCards.length - 1] || {};
                    return `顺子 ${firstCard.rank} ... ${endCard.rank}`;
                case PLAY_TYPE.CONSECUTIVE_PAIRS:
                    const endPairCard = displayCards[displayCards.length - 1] || {};
                    return `连对 ${firstCard.rank}${firstCard.rank} ... ${endPairCard.rank}${endPairCard.rank}`;
                default: return "出牌";
            }
        }
        
        function getDisplayCards(playedCards, playInfo) {
            if (playInfo.type === PLAY_TYPE.INVALID) return playedCards;
            if (playInfo.type === PLAY_TYPE.ROCKET) return playedCards;
            
            if (playInfo.type === PLAY_TYPE.SINGLE) {
                if (playInfo.cards[0].value !== playInfo.value) {
                    const fakeCard = getCardFromValue(playInfo.value);
                    return [{ ...fakeCard, isLaiziSub: true }];
                }
                return playedCards; 
            }

            const regulars = playedCards.filter(c => !LAIZI_VALUES.includes(c.value));
            let display = [];
            
            switch (playInfo.type) {
                case PLAY_TYPE.PAIR:
                case PLAY_TYPE.TRIO:
                case PLAY_TYPE.BOMB:
                    display = [...regulars];
                    while (display.length < playInfo.length) {
                        const fakeCard = getCardFromValue(playInfo.value);
                        display.push({ ...fakeCard, isLaiziSub: true });
                    }
                    return display;
                
                case PLAY_TYPE.STRAIGHT:
                    const startVal = playInfo.value;
                    for (let i = 0; i < playInfo.length; i++) {
                        const val = startVal + i;
                        const regCard = regulars.find(c => c.value === val);
                        if (regCard) {
                            display.push(regCard);
                        } else {
                            const fakeCard = getCardFromValue(val);
                            display.push({ ...fakeCard, isLaiziSub: true });
                        }
                    }
                    return display;
                
                case PLAY_TYPE.CONSECUTIVE_PAIRS:
                    const startValPairs = playInfo.value;
                    for (let i = 0; i < playInfo.length / 2; i++) {
                        const val = startValPairs + i;
                        const regCards = regulars.filter(c => c.value === val);
                        if (regCards.length === 2) {
                            display.push(...regCards);
                        } else if (regCards.length === 1) {
                            display.push(regCards[0]);
                            display.push({ ...getCardFromValue(val), isLaiziSub: true });
                        } else {
                            display.push({ ...getCardFromValue(val), isLaiziSub: true });
                            display.push({ ...getCardFromValue(val), isLaiziSub: true });
                        }
                    }
                    return display;

                case PLAY_TYPE.FULL_HOUSE:
                    const trioVal = playInfo.value;
                    const regularsTrio = regulars.filter(c => c.value === trioVal);
                    const regularsPairCards = regulars.filter(c => c.value !== trioVal);
                    
                    display = [...regularsTrio];
                    while (display.length < 3) {
                        display.push({ ...getCardFromValue(trioVal), isLaiziSub: true });
                    }
                    
                    if (regularsPairCards.length === 2) {
                        display.push(...regularsPairCards);
                    } else if (regularsPairCards.length === 1) {
                        display.push(regularsPairCards[0]);
                        display.push({ ...getCardFromValue(regularsPairCards[0].value), isLaiziSub: true });
                    } else { 
                        const pairVal = (regulars.length > 0 && regulars[0].value !== trioVal) ? regulars[0].value : (trioVal === 3 ? 4 : 3);
                        display.push({ ...getCardFromValue(pairVal), isLaiziSub: true });
                        display.push({ ...getCardFromValue(pairVal), isLaiziSub: true });
                    }
                    return display;
            }
            return playedCards; 
        }


        // (新) 重构: 查找所有可能的牌型
        function findAllPossiblePlays(cards) {
            if (!cards || cards.length === 0) return [];

            const len = cards.length;
            const sortedCards = [...cards].sort((a, b) => a.value - b.value);

            if (len === 2 && 
                sortedCards[0].value === SMALL_JOKER_VALUE && 
                sortedCards[1].value === BIG_JOKER_VALUE) {
                return [{ type: PLAY_TYPE.ROCKET, value: 999, cards: sortedCards, length: 2 }];
            }
            
            const laizi = sortedCards.filter(c => LAIZI_VALUES.includes(c.value));
            const regulars = sortedCards.filter(c => !LAIZI_VALUES.includes(c.value));
            const laiziCount = laizi.length;
            
            let possiblePlays = [];

            if (len === 1) {
                possiblePlays.push({ type: PLAY_TYPE.SINGLE, value: sortedCards[0].value, cards: sortedCards, length: 1 });
            }
            
            if (len === 2) {
                const pair = findPair(regulars, laiziCount);
                if (pair) possiblePlays.push({ type: PLAY_TYPE.PAIR, value: pair.value, cards: sortedCards, length: 2 });
            }
            
            if (len === 3) {
                const trio = findTrio(regulars, laiziCount);
                if (trio) possiblePlays.push({ type: PLAY_TYPE.TRIO, value: trio.value, cards: sortedCards, length: 3 });
                
                const straights = findAllStraights(regulars, laiziCount, len);
                straights.forEach(s => possiblePlays.push({ type: PLAY_TYPE.STRAIGHT, value: s.value, cards: sortedCards, length: len }));
            }
            
            if (len === 4) {
                const bomb = findBomb(regulars, laiziCount);
                if (bomb) possiblePlays.push({ type: PLAY_TYPE.BOMB, value: bomb.value, cards: sortedCards, length: 4 });
                
                const straights = findAllStraights(regulars, laiziCount, len);
                straights.forEach(s => possiblePlays.push({ type: PLAY_TYPE.STRAIGHT, value: s.value, cards: sortedCards, length: len }));
                
                const consPairs = findAllConsecutivePairs(regulars, laiziCount, len);
                consPairs.forEach(cp => possiblePlays.push({ type: PLAY_TYPE.CONSECUTIVE_PAIRS, value: cp.value, cards: sortedCards, length: len }));
            }
            
            if (len === 5) {
                const fullHouse = findFullHouse(regulars, laiziCount);
                if (fullHouse) possiblePlays.push({ type: PLAY_TYPE.FULL_HOUSE, value: fullHouse.value, cards: sortedCards, length: 5 });
                
                const straights = findAllStraights(regulars, laiziCount, len);
                straights.forEach(s => possiblePlays.push({ type: PLAY_TYPE.STRAIGHT, value: s.value, cards: sortedCards, length: len }));
            }
            
            if (len > 5) {
                 if (len % 2 === 0) {
                     const consPairs = findAllConsecutivePairs(regulars, laiziCount, len);
                     consPairs.forEach(cp => possiblePlays.push({ type: PLAY_TYPE.CONSECUTIVE_PAIRS, value: cp.value, cards: sortedCards, length: len }));
                 }
                 const straights = findAllStraights(regulars, laiziCount, len);
                 straights.forEach(s => possiblePlays.push({ type: PLAY_TYPE.STRAIGHT, value: s.value, cards: sortedCards, length: len }));
            }

            return possiblePlays;
        }
        
        // (新) getPlayType 现在只返回第一个可能
        function getPlayType(cards) {
             const plays = findAllPossiblePlays(cards);
             return plays.length > 0 ? plays[0] : { type: PLAY_TYPE.INVALID };
        }
        
        // --- 牌型查找辅助函数 (新) ---

        function findBomb(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 4) return null;
            if (regulars.length === 0) return { value: 3 }; 

            const valueCounts = {};
            regulars.forEach(c => { valueCounts[c.value] = (valueCounts[c.value] || 0) + 1; });
            
            for (const value in valueCounts) {
                if (valueCounts[value] + laiziCount >= 4) {
                    return { value: parseInt(value, 10) };
                }
            }
            return null; 
        }

        function findFullHouse(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 5) return null;
            if (regulars.length <= 1) return { value: 3 }; 

            const valueCounts = {};
            regulars.forEach(c => { valueCounts[c.value] = (valueCounts[c.value] || 0) + 1; });
            const uniqueValues = Object.keys(valueCounts).map(Number);
            
            if (uniqueValues.length === 1) { 
                return { value: uniqueValues[0] };
            }
            
            if (uniqueValues.length === 2) {
                const val1 = uniqueValues[0];
                const count1 = valueCounts[val1];
                const val2 = uniqueValues[1];
                const count2 = valueCounts[val2];
                
                let neededForTrio = 3 - count1;
                let neededForPair = 2 - count2;
                if (neededForTrio >= 0 && neededForPair >= 0 && neededForTrio + neededForPair <= laiziCount) {
                    return { value: val1 };
                }
                
                neededForTrio = 3 - count2;
                neededForPair = 2 - count1;
                if (neededForTrio >= 0 && neededForPair >= 0 && neededForTrio + neededForPair <= laiziCount) {
                    return { value: val2 };
                }
            }
            return null;
        }
        
        // (新) 查找所有顺子
        function findAllStraights(regulars, laiziCount, totalLength) {
            let possibleStraights = [];
            if (regulars.length === 0 && laiziCount >= totalLength) {
                 possibleStraights.push({ value: 3 }); 
                 return possibleStraights;
            }
            
            const uniqueValues = [...new Set(regulars.map(c => c.value))];
            uniqueValues.sort((a, b) => a - b);
            
            if (uniqueValues.some(v => v >= LAIZI_2_VALUE)) return []; 
            
            const minReg = uniqueValues.length > 0 ? uniqueValues[0] : LAIZI_2_VALUE;
            
            // (新) 迭代所有可能的起始点
            const maxPossibleStart = minReg;
            const minPossibleStart = Math.max(3, minReg - laiziCount); 

            for (let startVal = minPossibleStart; startVal <= maxPossibleStart; startVal++) {
                const endVal = startVal + totalLength - 1;
                if (endVal >= LAIZI_2_VALUE) continue; 

                let needed = 0;
                for (let v = startVal; v <= endVal; v++) {
                    if (!uniqueValues.includes(v)) {
                        needed++;
                    }
                }
                
                if (needed <= laiziCount) {
                    possibleStraights.push({ value: startVal }); 
                }
            }
            
            return possibleStraights; 
        }
        
        // (新) 查找所有连对
        function findAllConsecutivePairs(regulars, laiziCount, totalLength) {
            let possiblePairs = [];
            const numPairs = totalLength / 2;
            if (numPairs < 2) return [];
            if (regulars.length === 0 && laiziCount >= totalLength) {
                possiblePairs.push({ value: 3 });
                return possiblePairs;
            }

            const valueCounts = {};
            regulars.forEach(c => { valueCounts[c.value] = (valueCounts[c.value] || 0) + 1; });
            
            if (regulars.some(c => c.value >= LAIZI_2_VALUE)) return []; 
            
            const uniqueValues = [...new Set(regulars.map(c => c.value))];
            uniqueValues.sort((a, b) => a - b);
            const minReg = uniqueValues.length > 0 ? uniqueValues[0] : LAIZI_2_VALUE;

            const maxPossibleStart = minReg;
            const minPossibleStart = Math.max(3, minReg - laiziCount); 

            for (let startVal = minPossibleStart; startVal <= maxPossibleStart; startVal++) {
                const endVal = startVal + numPairs - 1;
                if (endVal >= LAIZI_2_VALUE) continue; 

                let needed = 0;
                for (let v = startVal; v <= endVal; v++) {
                    const countInRegs = valueCounts[v] || 0;
                    needed += Math.max(0, 2 - countInRegs);
                }
                
                if (needed <= laiziCount) {
                    possiblePairs.push({ value: startVal }); 
                }
            }
            return possiblePairs; 
        }

        function findTrio(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 3) return null;
            if (regulars.length === 0) return { value: 3 }; 
            
            const firstVal = regulars[0].value;
            if (regulars.every(c => c.value === firstVal)) {
                return { value: firstVal };
            }
            return null;
        }

        function findPair(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 2) return null;
            if (regulars.length === 0) return { value: 3 }; 
            
            const firstVal = regulars[0].value;
            if (regulars.every(c => c.value === firstVal)) {
                return { value: firstVal };
            }
            return null;
        }


        function isValidPlay(playInfo, lastPlay, isNewRound) {
            if (playInfo.type === PLAY_TYPE.INVALID) return false;
            
            if (isNewRound || !lastPlay) return true;

            if (playInfo.type === PLAY_TYPE.ROCKET) return true; 
            if (lastPlay.type === PLAY_TYPE.ROCKET) return false; 

            if (playInfo.type === PLAY_TYPE.BOMB) {
                if (lastPlay.type === PLAY_TYPE.BOMB) {
                    return playInfo.value === lastPlay.value + 1;
                }
                return true; 
            }
            
            if (lastPlay.type === PLAY_TYPE.BOMB) {
                return false; 
            }
            
            if (playInfo.type === PLAY_TYPE.SINGLE &&
                LAIZI_VALUES.includes(playInfo.value) &&
                lastPlay.type === PLAY_TYPE.SINGLE &&
                lastPlay.value < BIG_JOKER_VALUE)
            {
                return true;
            }

            if (playInfo.type === PLAY_TYPE.CONSECUTIVE_PAIRS) {
                if (lastPlay.type !== PLAY_TYPE.CONSECUTIVE_PAIRS) return false;
                if (playInfo.length !== lastPlay.length) return false;
                // (新) 连对也允许 A(14) -> 2(15)
                if (lastPlay.value === 14 && playInfo.value === 15) return true;
                return playInfo.value === lastPlay.value + 1;
            }
            if (lastPlay.type === PLAY_TYPE.CONSECUTIVE_PAIRS) return false; 

            if (playInfo.type !== lastPlay.type) return false;
            if (playInfo.type === PLAY_TYPE.STRAIGHT && playInfo.length !== lastPlay.length) return false;
            
            if (lastPlay.value === BIG_JOKER_VALUE) { 
                return false; 
            }
            
            if (playInfo.type === PLAY_TYPE.PAIR && lastPlay.value === 14 && playInfo.value === 15) {
                return true;
            }

            return playInfo.value === lastPlay.value + 1;
        }

        // --- 启动 ---
        initFirebase();

    </script>
</body>
</html>
