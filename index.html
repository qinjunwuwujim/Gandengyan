<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>干瞪眼 (在线版)</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自定义样式 */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
            overscroll-behavior: none;
            background-color: #1F2937; /* gray-800 */
        }
        
        /* 隐藏滚动条 */
        ::-webkit-scrollbar { display: none; }

        /* 游戏界面 */
        #game-board {
            display: grid;
            grid-template-rows: 1fr 2fr 1fr; /* 上、中、下 */
            grid-template-columns: 1fr 3fr 1fr; /* 左、中、右 */
            height: 100vh;
            width: 100vw;
            padding: 1rem;
            box-sizing: border-box;
            gap: 1rem;
        }

        /* 玩家位置 */
        #player-area-top { grid-area: 1 / 2 / 2 / 3; }
        #player-area-left { grid-area: 2 / 1 / 3 / 2; }
        #player-area-right { grid-area: 2 / 3 / 3 / 4; }
        #player-area-bottom { grid-area: 3 / 2 / 4 / 3; }
        #table-area { grid-area: 2 / 2 / 3 / 3; }

        .player-area {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }
        
        .player-area.active {
            border-color: #FCD34D; /* yellow-300 */
            box-shadow: 0 0 15px rgba(252, 211, 77, 0.3);
        }

        .player-info {
            position: absolute;
            background: rgba(0,0,0,0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: white;
            z-index: 10;
        }

        /* 调整不同位置的信息显示 */
        #player-area-top .player-info { bottom: 0.5rem; }
        #player-area-bottom .player-info { top: 0.5rem; }
        #player-area-left .player-info { right: 0.5rem; transform: rotate(90deg) translate(50%, 0); transform-origin: right center; }
        #player-area-right .player-info { left: 0.5rem; transform: rotate(-90deg) translate(-50%, 0); transform-origin: left center; }

        .hand-container {
            display: flex;
            flex-wrap: wrap; /* 允许换行 */
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* 竖排手牌 (左右玩家) */
        #player-area-left .hand-container,
        #player-area-right .hand-container {
            flex-direction: column;
            flex-wrap: nowrap;
        }

        /* 卡片 */
        .card {
            width: 64px;
            height: 90px;
            border-radius: 6px;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 16px;
            font-weight: bold;
            position: relative;
            transition: all 0.2s ease-out;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden; /* 确保内容不溢出 */
        }
        .card.face-down {
            background-color: #3B82F6;
            background-image: linear-gradient(135deg, #60A5FA 25%, transparent 25%), linear-gradient(225deg, #60A5FA 25%, transparent 25%), linear-gradient(45deg, #60A5FA 25%, transparent 25%), linear-gradient(315deg, #60A5FA 25%, #3B82F6 25%);
            background-position: 8px 0, 8px 0, 0 0, 0 0;
            background-size: 16px 16px;
            background-repeat: repeat;
        }
        .card .rank { line-height: 1; padding: 4px; }
        .card .suit { font-size: 18px; line-height: 1; text-align: center; }
        .card .rank.bottom { padding: 4px; align-self: flex-end; transform: rotate(180deg); }
        .card[data-suit="♥"], .card[data-suit="♦"] { color: #EF4444; }
        .card[data-suit="♠"], .card[data-suit="♣"] { color: #1F2937; }
        
        /* 癞子牌的特殊颜色 */
        .card.laizi {
            color: #F59E0B; /* A golden/orange color for all laizi */
            border: 2px solid #F59E0B;
        }
        .card[data-value="17"].laizi { color: #EF4444; border-color: #EF4444; } /* Big Joker remains red */
        .card[data-value="16"].laizi { color: #1F2937; border-color: #1F2937; } /* Small Joker remains black */


        /* 玩家自己的手牌 */
        #player-hand .card {
            cursor: pointer;
        }
        #player-hand .card.selected {
            transform: translateY(-15px);
            border-color: #FCD34D;
            border-width: 3px;
            box-shadow: 0 8px 15px rgba(252, 211, 77, 0.3);
        }
        
        /* 桌面中央 */
        #table-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }
        #draw-pile-container {
            position: relative;
            width: 64px;
            height: 90px;
        }
        .deck-count {
            position: absolute;
            bottom: -20px;
            width: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.875rem;
            color: #D1D5DB;
            text-align: center;
        }
        #last-play-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            min-height: 90px;
            min-width: 100px;
            gap: -20px;
            padding-left: 20px;
        }
        #last-play-area .card {
            margin-left: -20px;
            cursor: default;
        }
        
        /* 覆盖层 (弹窗) */
        .overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 50;
            color: #1F2937;
        }
        .modal {
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        /* 按钮 */
        .btn {
            padding: 10px 20px;
            font-weight: bold;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s;
            cursor: pointer;
        }
        .btn:disabled {
            background-color: #6B7280 !important;
            opacity: 0.7;
            cursor: not-allowed;
        }
        .btn-green { background-color: #10B981; color: white; }
        .btn-green:hover { background-color: #059669; }
        .btn-blue { background-color: #3B82F6; color: white; }
        .btn-blue:hover { background-color: #2563EB; }
        .btn-red { background-color: #EF4444; color: white; }
        .btn-red:hover { background-color: #DC2626; }
        
        /* 消息提示 */
        #message-area {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #FCD34D;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            z-index: 100;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        #message-area.show {
            opacity: 1;
        }
        
        /* 游戏内退出按钮 */
        #ingame-leave-btn {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 40;
        }
    </style>
</head>
<body class="text-white">

    <!-- 游戏主界面 (默认隐藏) -->
    <div id="game-board" class="hidden">
        
        <button id="ingame-leave-btn" class="btn btn-red">返回大厅</button>
        
        <div id="player-area-top" class="player-area hidden">
            <div id="player-info-top" class="player-info">玩家 2 (0 张)</div>
            <div id="player-hand-top" class="hand-container"></div>
        </div>
        
        <div id="player-area-left" class="player-area hidden">
            <div id="player-info-left" class="player-info">玩家 1 (0 张)</div>
            <div id="player-hand-left" class="hand-container"></div>
        </div>

        <div id="table-area">
            <div id="draw-pile-container">
                <div class="card face-down"></div>
                <div id="draw-pile-count" class="deck-count">剩余: 0</div>
            </div>
            <div id="last-play-area"></div>
        </div>

        <div id="player-area-right" class="player-area hidden">
            <div id="player-info-right" class="player-info">玩家 3 (0 张)</div>
            <div id="player-hand-right" class="hand-container"></div>
        </div>
        
        <div id="player-area-bottom" class="player-area">
            <div id="player-info-bottom" class="player-info">你 (0 张)</div>
            <div class="absolute bottom-2 right-2 flex gap-2 z-10">
                <button id="play-button" class="btn btn-green">出牌</button>
                <button id="pass-draw-button" class="btn btn-blue">摸牌 / 过</button>
            </div>
            <div id="player-hand" class="hand-container p-4 overflow-x-auto w-full">
                <!-- 玩家的牌 -->
            </div>
        </div>
    </div>

    <!-- 加载界面 (默认显示) -->
    <div id="loading-screen" class="overlay">
        <div class="modal">
            <h2 class="text-2xl font-bold mb-4">正在连接...</h2>
            <p id="loading-status">正在连接到 Firebase 并进行身份验证...</p>
        </div>
    </div>
    
    <!-- 大厅界面 -->
    <div id="lobby-screen" class="overlay hidden">
        <div class="modal">
            <h2 class="text-2xl font-bold mb-4">干瞪眼 (在线版)</h2>
            <p class="mb-2">你的用户 ID: <strong id="user-id-display" class="text-xs break-all"></strong></p>
            <div class="flex flex-col gap-4">
                <button id="create-room-btn" class="btn btn-green" disabled>创建房间</button>
                <hr>
                <input id="room-id-input" type="text" placeholder="输入房间 ID 或邀请链接" class="p-2 border rounded text-center">
                <button id="join-room-btn" class="btn btn-blue" disabled>加入房间</button>
            </div>
        </div>
    </div>
    
    <!-- 等待室界面 -->
    <div id="waiting-room-screen" class="overlay hidden">
        <div class="modal">
            <h2 class="text-xl font-bold mb-4">等待室</h2>
            <p id="waiting-room-prompt" class="mb-2">分享这个【邀请链接】给你的朋友:</p>
            <input id="room-id-display" type="text" readonly class="p-2 border rounded text-center w-full font-bold text-sm mb-4" onclick="this.select()">
            
            <h3 class="font-bold mb-2">已加入的玩家 (<span id="player-count">1</span>/4):</h3>
            <ul id="player-list" class="list-disc list-inside mb-4 text-left">
                <!-- 玩家列表 -->
            </ul>
            
            <button id="start-game-btn" class="btn btn-green hidden">开始游戏 (2-4 人)</button>
            <button id="leave-room-btn" class="btn btn-red mt-2">离开房间</button>
        </div>
    </div>

    <!-- 游戏结束弹窗 -->
    <div id="game-over-modal" class="overlay hidden">
        <div class="modal">
            <h2 id="game-over-title" class="text-3xl font-bold mb-4">游戏结束</h2>
            <p id="game-over-message" class="text-lg mb-6">玩家 1 赢了!</p>
            <button id="back-to-lobby-btn" class="btn btn-green">返回大厅</button>
        </div>
    </div>
    
    <!-- 消息提示框 -->
    <div id="message-area"></div>

    <!-- Firebase SDK -->
    <script type="module">
        // 导入 Firebase 模块
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction, writeBatch, arrayUnion, arrayRemove, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- 全局变量 ---
        let db, auth;
        let userId, appId;
        let currentRoomId = null;
        let localHand = [];
        let selectedIndices = [];
        let gameUnsubscribe = null;
        let handUnsubscribe = null;
        let myPlayerIndex = 0; 

        // --- UI 元素 ---
        const loadingScreen = document.getElementById('loading-screen');
        const loadingStatus = document.getElementById('loading-status');
        const lobbyScreen = document.getElementById('lobby-screen');
        const waitingRoomScreen = document.getElementById('waiting-room-screen');
        const gameBoard = document.getElementById('game-board');
        const gameOverModal = document.getElementById('game-over-modal');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');

        // --- 牌型定义 ---
        const SUITS = ['♥', '♦', '♣', '♠'];
        const RANKS = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
        const RANK_VALUES = {};
        RANKS.forEach((rank, index) => { RANK_VALUES[rank] = index + 3; }); // 3=3 ... A=14
        
        const LAIZI_2_VALUE = RANK_VALUES['2']; // 15 (这是 2)
        const SMALL_JOKER_VALUE = 16;
        const BIG_JOKER_VALUE = 17;
        // (新) 所有癞子的值
        const LAIZI_VALUES = [LAIZI_2_VALUE, SMALL_JOKER_VALUE, BIG_JOKER_VALUE];
        
        const PLAY_TYPE = {
            INVALID: 'INVALID', SINGLE: 'SINGLE', PAIR: 'PAIR', TRIO: 'TRIO',
            FULL_HOUSE: 'FULL_HOUSE', STRAIGHT: 'STRAIGHT', BOMB: 'BOMB',
            ROCKET: 'ROCKET' // 王炸
        };

        // --- 1. 初始化 Firebase ---
        
        async function initFirebase() {
            try {
                // (修复) 直接使用你提供的 firebaseConfig
                const firebaseConfig = {
                  apiKey: "AIzaSyCmSAI_ojtg7mEWQJ_hfZBWMTxy0nHh1nk",
                  authDomain: "gandengyan-32d4a.firebaseapp.com",
                  projectId: "gandengyan-32d4a",
                  storageBucket: "gandengyan-32d4a.firebasestorage.app",
                  messagingSenderId: "1088497241628",
                  appId: "1:1088497241628:web:f957fa04eb4152b26c59d9",
                  measurementId: "G-NNRVFGYEGZ"
                };
                
                appId = firebaseConfig.projectId; 

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, async (user) => {
                    if (!user) {
                        loadingStatus.textContent = "正在登录...";
                        try {
                            await signInAnonymously(auth);
                        } catch (authError) {
                            console.error("Auth Error:", authError);
                            throw new Error(`身份验证失败: ${authError.message}`);
                        }
                        return;
                    }
                    
                    userId = user.uid;
                    document.getElementById('user-id-display').textContent = userId;
                    createRoomBtn.disabled = false;
                    joinRoomBtn.disabled = false;

                    const params = new URLSearchParams(window.location.search);
                    const roomIdFromUrl = params.get('room');

                    if (roomIdFromUrl) {
                        showMessage(`正在自动加入房间 ${roomIdFromUrl}...`);
                        document.getElementById('room-id-input').value = roomIdFromUrl;
                        await autoJoinRoom(roomIdFromUrl);
                    } else {
                        showScreen('lobby');
                    }
                });
                
            } catch (error) {
                console.error("Firebase Init Error:", error);
                loadingScreen.innerHTML = `<div class="modal"><h2 class="text-2xl font-bold mb-4 text-red-600">连接失败</h2><p>${error.message}</p></div>`;
            }
        }
        
        function getRoomIdFromInput(input) {
            let roomId = input.trim().toUpperCase();
            try {
                const url = new URL(input);
                const roomParam = url.searchParams.get('room');
                if (roomParam) {
                    roomId = roomParam.toUpperCase();
                }
            } catch (e) {
                // 不是 URL，就假定它是房间 ID
            }
            return roomId;
        }

        async function autoJoinRoom(roomId) {
            joinRoomBtn.disabled = true; 
            
            const roomRef = doc(db, paths.room(roomId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) {
                        throw new Error("房间不存在 (来自链接)");
                    }
                    
                    const roomData = roomSnap.data();
                    if (roomData.status !== "waiting") {
                        throw new Error("游戏已开始 (来自链接)");
                    }
                    
                    if (roomData.players.length >= 4) {
                        throw new Error("房间已满 (来自链接)");
                    }
                    
                    if (!roomData.players.some(p => p.uid === userId)) {
                        const newPlayer = { uid: userId, name: `玩家 ${roomData.players.length + 1}`, cardCount: 0 };
                        transaction.update(roomRef, {
                            players: arrayUnion(newPlayer),
                            log: arrayUnion(`${newPlayer.name} 已加入。`)
                        });
                    }
                });

                await joinRoom(roomId); 
                
            } catch (error) {
                console.error("Auto-join Error:", error);
                showMessage("自动加入失败: " + error.message);
                joinRoomBtn.disabled = false;
                showScreen('lobby'); 
                window.history.pushState({}, '', window.location.pathname); 
            }
        }

        // --- 2. UI 屏幕管理 ---

        function showScreen(screenId) {
            loadingScreen.classList.add('hidden');
            lobbyScreen.classList.add('hidden');
            waitingRoomScreen.classList.add('hidden');
            gameBoard.classList.add('hidden');
            gameOverModal.classList.add('hidden');
            
            if (screenId === 'waiting-room') {
                waitingRoomScreen.classList.remove('hidden');
                return;
            }

            const screenElement = document.getElementById(`${screenId}-screen`);
            if (screenElement) {
                screenElement.classList.remove('hidden');
            } else if (screenId === 'game-board') {
                 gameBoard.classList.remove('hidden');
            }
        }
        
        function showMessage(msg) {
            const msgArea = document.getElementById('message-area');
            if (!msgArea) return; 
            msgArea.textContent = msg;
            msgArea.classList.add('show');
            setTimeout(() => msgArea.classList.remove('show'), 2000);
        }

        // --- 3. 路径助手 ---
        const paths = {
            room: (roomId) => `/artifacts/${appId}/public/data/gandengyan-rooms/${roomId}`,
            hand: (roomId, uid) => `/artifacts/${appId}/public/data/gandengyan-hands/${roomId}-${uid}`
        };
        
        // --- 4. 大厅逻辑 (创建/加入) ---
        
        createRoomBtn.onclick = async () => {
            const btn = createRoomBtn;
            btn.disabled = true;
            btn.textContent = "创建中...";
            
            const roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            const roomRef = doc(db, paths.room(roomId));
            
            const initialRoomData = {
                roomId: roomId,
                hostId: userId,
                players: [{ uid: userId, name: `玩家 1`, cardCount: 0 }], 
                status: "waiting", 
                drawPile: [],
                lastPlayedCards: [],
                lastPlayerId: null, // (新) 添加最后出牌者
                currentPlay: null,
                currentPlayerIndex: 0,
                isNewRound: true,
                log: [`房间 ${roomId} 已创建。`],
                winner: null
            };
            
            try {
                await setDoc(roomRef, initialRoomData);
                await joinRoom(roomId); 
            } catch (error) {
                console.error("Create Room Error:", error);
                showMessage("创建房间失败: " + error.message);
                btn.disabled = false;
            } finally {
                btn.textContent = "创建房间";
            }
        };

        joinRoomBtn.onclick = async () => {
            const inputVal = document.getElementById('room-id-input').value;
            const roomId = getRoomIdFromInput(inputVal); 
            
            if (!roomId) {
                 showMessage("请输入有效的房间 ID 或邀请链接");
                 return;
            }
            
            const btn = joinRoomBtn;
            btn.disabled = true;
            
            const roomRef = doc(db, paths.room(roomId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) {
                        throw new Error("房间不存在"); 
                    }
                    
                    const roomData = roomSnap.data();
                    if (roomData.status !== "waiting") {
                        throw new Error("游戏已开始或已结束");
                    }
                    
                    if (roomData.players.length >= 4) {
                        throw new Error("房间已满");
                    }
                    
                    if (!roomData.players.some(p => p.uid === userId)) {
                        const newPlayer = { uid: userId, name: `玩家 ${roomData.players.length + 1}`, cardCount: 0 };
                        transaction.update(roomRef, {
                            players: arrayUnion(newPlayer),
                            log: arrayUnion(`${newPlayer.name} 已加入。`)
                        });
                    }
                });

                await joinRoom(roomId); 
                
            } catch (error) {
                console.error("Join Room Error:", error);
                showMessage("加入失败: " + error.message);
                btn.disabled = false;
            }
        };

        // --- 5. 等待室逻辑 ---
        
        async function joinRoom(roomId) {
            currentRoomId = roomId;
            
            const roomRef = doc(db, paths.room(roomId));
            gameUnsubscribe = onSnapshot(roomRef, (docSnap) => {
                if (!docSnap.exists()) {
                    if (currentRoomId) { 
                        showMessage("房间不存在或已解散");
                        leaveRoom(false);
                    }
                    return;
                }
                renderGameState(docSnap.data());
            }, (error) => {
                console.error("Room subscription error:", error);
                leaveRoom(false);
                showMessage("房间连接错误: " + error.message);
            });
            
            const handRef = doc(db, paths.hand(roomId, userId));
            handUnsubscribe = onSnapshot(handRef, (docSnap) => {
                if (docSnap.exists()) {
                    localHand = docSnap.data().cards;
                    renderPlayerHand();
                } else {
                    localHand = []; 
                    renderPlayerHand();
                }
            });

            showScreen('waiting-room');
            
            const inviteLink = `${window.location.origin}${window.location.pathname}?room=${roomId}`;
            document.getElementById('room-id-display').value = inviteLink;
            document.getElementById('waiting-room-prompt').textContent = "分享这个【邀请链接】给你的朋友:";
        }
        
        document.getElementById('leave-room-btn').onclick = () => leaveRoom(true);
        document.getElementById('ingame-leave-btn').onclick = () => leaveRoom(true);
        document.getElementById('back-to-lobby-btn').onclick = () => leaveRoom(false); 

        async function leaveRoom(updateDB) {
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null; 
            }
            if (handUnsubscribe) {
                handUnsubscribe();
                handUnsubscribe = null; 
            }
            
            const roomId = currentRoomId;
            const uid = userId;
            
            currentRoomId = null;
            localHand = [];
            selectedIndices = [];

            if (updateDB && roomId && uid) {
                const roomRef = doc(db, paths.room(roomId));
                const handRef = doc(db, paths.hand(roomId, uid));
                
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomSnap = await transaction.get(roomRef);
                        if (!roomSnap.exists()) return;
                        
                        const roomData = roomSnap.data();
                        if (roomData.status === 'finished') return;

                        const newPlayers = roomData.players.filter(p => p.uid !== uid);
                        
                        if (newPlayers.length === 0) {
                            transaction.delete(roomRef);
                        } else {
                            let newHostId = roomData.hostId;
                            if (roomData.hostId === uid) {
                                newHostId = newPlayers[0].uid;
                            }
                            transaction.update(roomRef, {
                                players: newPlayers,
                                hostId: newHostId,
                                log: arrayUnion(`玩家 ${uid.substring(0,4)} 已离开。`)
                            });
                        }
                        transaction.delete(handRef);
                    });
                } catch (error) {
                    console.error("Leave Room Error:", error);
                }
            }
            
            showScreen('lobby');
            window.history.pushState({}, '', window.location.pathname);
        }

        // --- 6. 渲染游戏状态 (核心) ---
        
        function renderGameState(roomData) {
            if (!roomData || !currentRoomId) return;

            if (roomData.status === "waiting") {
                showScreen('waiting-room');
                const inviteLink = `${window.location.origin}${window.location.pathname}?room=${roomData.roomId}`;
                document.getElementById('room-id-display').value = inviteLink;
                
                const playerList = document.getElementById('player-list');
                playerList.innerHTML = '';
                roomData.players.forEach(p => {
                    const li = document.createElement('li');
                    li.textContent = `${p.name} ${p.uid === roomData.hostId ? '(房主)' : ''} ${p.uid === userId ? '(你)' : ''}`;
                    playerList.appendChild(li);
                });
                document.getElementById('player-count').textContent = roomData.players.length;
                
                const startBtn = document.getElementById('start-game-btn');
                if (roomData.hostId === userId && roomData.players.length >= 2) {
                    startBtn.classList.remove('hidden');
                    startBtn.textContent = `开始游戏 (${roomData.players.length} 人)`;
                } else {
                    startBtn.classList.add('hidden');
                }
                
            } else if (roomData.status === "playing") {
                if (window.location.search.includes('room=')) {
                    window.history.pushState({}, '', window.location.pathname);
                }
                showScreen('game-board');
                
                const numPlayers = roomData.players.length;
                myPlayerIndex = roomData.players.findIndex(p => p.uid === userId);
                if (myPlayerIndex === -1) {
                    console.warn("User not in player list.");
                    leaveRoom(false);
                    return;
                }
                
                const areas = [
                    { id: 'bottom', handEl: 'player-hand', infoEl: 'player-info-bottom', areaEl: 'player-area-bottom', playerIdx: 0 },
                    { id: 'left',   handEl: 'player-hand-left', infoEl: 'player-info-left', areaEl: 'player-area-left', playerIdx: 1 }, 
                    { id: 'top',    handEl: 'player-hand-top', infoEl: 'player-info-top', areaEl: 'player-area-top', playerIdx: 2 }, 
                    { id: 'right',  handEl: 'player-hand-right', infoEl: 'player-info-right', areaEl: 'player-area-right', playerIdx: 3 }
                ];
                
                areas.forEach(a => document.getElementById(a.areaEl).classList.add('hidden'));

                let displayMap = [];
                if (numPlayers === 2) {
                    displayMap[0] = areas[0]; // 我
                    displayMap[1] = areas[2]; // 对面
                } else if (numPlayers === 3) {
                    displayMap[0] = areas[0]; // 我
                    displayMap[1] = areas[1]; // 左
                    displayMap[2] = areas[3]; // 右
                } else {
                    displayMap[0] = areas[0];
                    displayMap[1] = areas[1];
                    displayMap[2] = areas[2];
                    displayMap[3] = areas[3];
                }

                for (let i = 0; i < numPlayers; i++) {
                    const player = roomData.players[i];
                    const relativeIndex = (i - myPlayerIndex + numPlayers) % numPlayers;
                    
                    const area = displayMap[relativeIndex];
                    if (!area) continue; 

                    const areaEl = document.getElementById(area.areaEl);
                    const infoEl = document.getElementById(area.infoEl);
                    const handEl = document.getElementById(area.handEl);
                    
                    areaEl.classList.remove('hidden'); 
                    infoEl.textContent = `${player.name} (${player.cardCount} 张)`;
                    
                    if (i === roomData.currentPlayerIndex) {
                        areaEl.classList.add('active');
                    } else {
                        areaEl.classList.remove('active');
                    }
                    
                    if (relativeIndex !== 0) { 
                        handEl.innerHTML = '';
                        for (let c = 0; c < player.cardCount; c++) {
                            handEl.appendChild(createCardElement(null, true));
                        }
                    }
                }
                
                document.getElementById('draw-pile-count').textContent = `剩余: ${roomData.drawPile.length}`;
                
                const lastPlayArea = document.getElementById('last-play-area');
                lastPlayArea.innerHTML = '';
                if (roomData.lastPlayedCards.length > 0) {
                    roomData.lastPlayedCards.forEach(card => {
                        lastPlayArea.appendChild(createCardElement(card));
                    });
                }
                
                const isMyTurn = roomData.currentPlayerIndex === myPlayerIndex;
                document.getElementById('play-button').disabled = !isMyTurn;
                document.getElementById('pass-draw-button').disabled = !isMyTurn;
                
                if (roomData.drawPile.length === 0) {
                    document.getElementById('pass-draw-button').textContent = '过 (Pass)';
                } else {
                    document.getElementById('pass-draw-button').textContent = '摸牌 / 过';
                }

            } else if (roomData.status === "finished") {
                document.getElementById('game-over-title').textContent = roomData.winner === userId ? "恭喜你！" : "很遗憾...";
                const winnerName = roomData.players.find(p => p.uid === roomData.winner)?.name || "??";
                document.getElementById('game-over-message').textContent = `${winnerName} 赢得了游戏!`;
                gameOverModal.classList.remove('hidden');
                
                if (gameUnsubscribe) gameUnsubscribe();
                if (handUnsubscribe) handUnsubscribe();
                gameUnsubscribe = null;
                handUnsubscribe = null;
            }
        }
        
        // --- 7. 渲染玩家手牌 (自己) ---
        
        function renderPlayerHand() {
            const playerHandArea = document.getElementById('player-hand');
            if (!playerHandArea) return; 
            
            playerHandArea.innerHTML = '';
            // (新) 排序: 3-A 在前, 癞子 (2, 小王, 大王) 在后
            localHand.sort((a, b) => {
                const aIsLaizi = LAIZI_VALUES.includes(a.value);
                const bIsLaizi = LAIZI_VALUES.includes(b.value);
                
                if (aIsLaizi && !bIsLaizi) return 1;
                if (!aIsLaizi && bIsLaizi) return -1;

                // 都是癞子, 或都不是癞子, 按 value 排序
                return a.value - b.value || a.suit.localeCompare(b.suit);
            });
            
            localHand.forEach((card, index) => {
                const cardDiv = createCardElement(card);
                if (selectedIndices.includes(index)) {
                    cardDiv.classList.add('selected');
                }
                cardDiv.addEventListener('click', () => toggleCardSelection(index));
                playerHandArea.appendChild(cardDiv);
            });
            
            const infoBottom = document.getElementById('player-info-bottom');
            if (infoBottom && infoBottom.textContent) {
                const name = infoBottom.textContent.split('(')[0] || '你';
                infoBottom.textContent = `${name}(${localHand.length} 张)`;
            }
        }

        function createCardElement(card, isFaceDown = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            
            if (isFaceDown) {
                cardDiv.classList.add('face-down');
            } else {
                cardDiv.dataset.value = card.value;
                
                if (LAIZI_VALUES.includes(card.value)) {
                    cardDiv.classList.add('laizi');
                }

                // (新) 渲染大小王
                if (card.value === BIG_JOKER_VALUE) {
                    cardDiv.innerHTML = `<div class="rank" style="font-size: 12px; line-height: 1.2;">BIG</div><div class="suit" style="font-size: 14px;">JOKER</div><div class="rank bottom" style="font-size: 12px; line-height: 1.2;">BIG</div>`;
                } else if (card.value === SMALL_JOKER_VALUE) {
                    cardDiv.innerHTML = `<div class="rank" style="font-size: 12px; line-height: 1.2;">small</div><div class="suit" style="font-size: 14px;">joker</div><div class="rank bottom" style="font-size: 12px; line-height: 1.2;">small</div>`;
                } else {
                    // 渲染普通牌
                    cardDiv.dataset.suit = card.suit;
                    cardDiv.innerHTML = `
                        <div class="rank">${card.rank}</div>
                        <div class="suit">${card.suit}</div>
                        <div class="rank bottom">${card.rank}</div>
                    `;
                }
            }
            return cardDiv;
        }

        function toggleCardSelection(index) {
            const selIndex = selectedIndices.indexOf(index);
            if (selIndex > -1) {
                selectedIndices.splice(selIndex, 1);
            } else {
                selectedIndices.push(index);
            }
            renderPlayerHand();
        }
        
        // --- 8. 游戏逻辑 (开始/出牌/摸牌) ---
        
        document.getElementById('start-game-btn').onclick = async () => {
            if (!currentRoomId || !appId) return;
            
            const roomRef = doc(db, paths.room(currentRoomId));
            const roomSnap = await getDoc(roomRef);
            if (!roomSnap.exists()) return;
            const roomData = roomSnap.data();
            const players = roomData.players;
            const numPlayers = players.length;

            if (numPlayers < 2 || numPlayers > 4) {
                showMessage("必须有 2-4 名玩家才能开始。");
                return;
            }
            
            let deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push({ suit, rank, value: RANK_VALUES[rank] });
                }
            }
            // (新) 添加大小王
            deck.push({ suit: 'Joker', rank: 'Small', value: SMALL_JOKER_VALUE });
            deck.push({ suit: 'Joker', rank: 'Big', value: BIG_JOKER_VALUE });
            
            // 洗牌
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            
            const hands = [];
            for (let i = 0; i < numPlayers; i++) hands.push([]);
            
            // 发牌
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < numPlayers; j++) {
                    if (deck.length > 0) {
                        hands[j].push(deck.pop());
                    }
                }
            }
            
            try {
                const batch = writeBatch(db);
                
                for (let i = 0; i < numPlayers; i++) {
                    const uid = players[i].uid;
                    const handRef = doc(db, paths.hand(currentRoomId, uid));
                    batch.set(handRef, { cards: hands[i] });
                }
                
                const updatedPlayers = players.map(p => ({ ...p, cardCount: 6 }));
                
                batch.update(roomRef, {
                    status: "playing",
                    drawPile: deck,
                    players: updatedPlayers,
                    currentPlayerIndex: 0,
                    isNewRound: true,
                    lastPlayedCards: [],
                    lastPlayerId: null, // (新)
                    currentPlay: null,
                    log: arrayUnion("游戏开始！")
                });
                
                await batch.commit();
                
            } catch (error) {
                console.error("Start Game Error:", error);
                showMessage("开始游戏失败: " + error.message);
            }
        };

        // 玩家出牌
        document.getElementById('play-button').onclick = async () => {
            const btn = document.getElementById('play-button');
            if (selectedIndices.length === 0) {
                showMessage("请选择要出的牌");
                return;
            }
            if (!currentRoomId || !appId) return;
            btn.disabled = true;

            const selectedCards = selectedIndices.map(i => localHand[i]).sort((a, b) => a.value - b.value);

            const roomRef = doc(db, paths.room(currentRoomId));
            const handRef = doc(db, paths.hand(currentRoomId, userId));

            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    const handSnap = await transaction.get(handRef);
                    
                    if (!roomSnap.exists() || !handSnap.exists()) throw new Error("房间或手牌不存在");
                    
                    const roomData = roomSnap.data();
                    const handData = handSnap.data();
                    const numPlayers = roomData.players.length;
                    
                    if (roomData.status !== "playing") throw new Error("游戏未在进行");
                    if (roomData.players[roomData.currentPlayerIndex].uid !== userId) throw new Error("还没轮到你");
                    
                    let drawnCard = null;
                    let newDrawPile = [...roomData.drawPile];
                    // (新) 摸牌逻辑: 只有在 isNewRound 时才摸牌
                    if (roomData.isNewRound && newDrawPile.length > 0) {
                        drawnCard = newDrawPile.pop();
                    }
                    
                    const playInfo = getPlayType(selectedCards);

                    if (!isValidPlay(playInfo, roomData.currentPlay, roomData.isNewRound)) {
                        throw new Error("无效的出牌！");
                    }
                    
                    let newHand = handData.cards.filter((_, index) => !selectedIndices.includes(index));
                    if (drawnCard) {
                        newHand.push(drawnCard);
                    }
                    
                    transaction.set(handRef, { cards: newHand });
                    
                    const newPlayerIndex = (roomData.currentPlayerIndex + 1) % numPlayers;
                    const updatedPlayers = [...roomData.players];
                    updatedPlayers[myPlayerIndex].cardCount = newHand.length;
                    
                    let newStatus = roomData.status;
                    let winner = null;
                    if (newHand.length === 0) {
                        newStatus = "finished";
                        winner = userId;
                    }
                    
                    transaction.update(roomRef, {
                        lastPlayedCards: selectedCards,
                        currentPlay: playInfo,
                        lastPlayerId: userId, // (新) 记录最后出牌者
                        isNewRound: false, // (新) 出牌后总是不是 newRound
                        currentPlayerIndex: newPlayerIndex,
                        players: updatedPlayers,
                        status: newStatus,
                        winner: winner,
                        drawPile: newDrawPile,
                        log: arrayUnion(`${roomData.players[myPlayerIndex].name} ${drawnCard ? '摸牌并' : ''}出牌了。`)
                    });
                });
                
                selectedIndices = []; 
                
            } catch (error) {
                console.error("Play Card Error:", error);
                showMessage(error.message);
                btn.disabled = false;
            }
        };
        
        // 玩家摸牌 / 过
        document.getElementById('pass-draw-button').onclick = async () => {
            const btn = document.getElementById('pass-draw-button');
            if (!currentRoomId || !appId) return;
            btn.disabled = true;
            
            const roomRef = doc(db, paths.room(currentRoomId));
            const handRef = doc(db, paths.hand(currentRoomId, userId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    const handSnap = await transaction.get(handRef);
                    
                    if (!roomSnap.exists() || !handSnap.exists()) throw new Error("房间或手牌不存在");
                    
                    const roomData = roomSnap.data();
                    const handData = handSnap.data();
                    const numPlayers = roomData.players.length;
                    
                    if (roomData.status !== "playing") throw new Error("游戏未在进行");
                    if (roomData.players[roomData.currentPlayerIndex].uid !== userId) throw new Error("还没轮到你");
                    
                    const newHand = [...handData.cards];
                    const newDrawPile = [...roomData.drawPile];
                    let logMsg = `${roomData.players[myPlayerIndex].name} 选择'过'。`;
                    
                    if (newDrawPile.length > 0) {
                        const drawnCard = newDrawPile.pop();
                        newHand.push(drawnCard);
                        logMsg = `${roomData.players[myPlayerIndex].name} 摸了一张牌。`;
                    }
                    
                    transaction.set(handRef, { cards: newHand });
                    
                    const newPlayerIndex = (roomData.currentPlayerIndex + 1) % numPlayers;
                    const updatedPlayers = [...roomData.players];
                    updatedPlayers[myPlayerIndex].cardCount = newHand.length;
                    
                    // (新) 摸牌逻辑: 检查下一回合是否是新回合
                    const nextPlayerUid = roomData.players[newPlayerIndex].uid;
                    const nextPlayerIsNewRound = (nextPlayerUid === roomData.lastPlayerId) || roomData.lastPlayerId === null;

                    transaction.update(roomRef, {
                        drawPile: newDrawPile,
                        players: updatedPlayers,
                        currentPlayerIndex: newPlayerIndex,
                        isNewRound: nextPlayerIsNewRound, // (新)
                        log: arrayUnion(logMsg)
                    });
                });
                
                selectedIndices = [];
                
            } catch (error) {
                console.error("Pass/Draw Error:", error);
                showMessage(error.message);
                btn.disabled = false;
            }
        };
        
        // --- 9. 牌型验证 (含所有癞子) ---

        /**
         * 检查一组牌的牌型 (新: 2, 小王, 大王 都是癞子)
         */
        function getPlayType(cards) {
            if (!cards || cards.length === 0) return { type: PLAY_TYPE.INVALID };

            const len = cards.length;
            const sortedCards = [...cards].sort((a, b) => a.value - b.value);

            // 1. 检查王炸 (特殊, 不算癞子)
            if (len === 2 && 
                sortedCards[0].value === SMALL_JOKER_VALUE && 
                sortedCards[1].value === BIG_JOKER_VALUE) {
                return { type: PLAY_TYPE.ROCKET, value: 999, cards: sortedCards, length: 2 };
            }
            
            // 2. 分离癞子和常规牌
            const laizi = sortedCards.filter(c => LAIZI_VALUES.includes(c.value));
            const regulars = sortedCards.filter(c => !LAIZI_VALUES.includes(c.value));
            const laiziCount = laizi.length;

            // 3. 查找最佳组合 (炸弹 > 顺子/三带二 > 三条 > 对子 > 单)
            
            // 查找炸弹 (4张)
            if (len === 4) {
                const bomb = findBomb(regulars, laiziCount);
                if (bomb) return { type: PLAY_TYPE.BOMB, value: bomb.value, cards: sortedCards, length: 4 };
            }

            // 查找三带二 (5张)
            if (len === 5) {
                const fullHouse = findFullHouse(regulars, laiziCount);
                if (fullHouse) return { type: PLAY_TYPE.FULL_HOUSE, value: fullHouse.value, cards: sortedCards, length: 5 };
            }
            
            // 查找顺子 (>=3张, 且不能包含癞子值)
            if (len >= 3) {
                const straight = findStraight(regulars, laiziCount, len);
                if (straight) return { type: PLAY_TYPE.STRAIGHT, value: straight.value, cards: sortedCards, length: len };
            }

            // 查找三条 (3张)
            if (len === 3) {
                const trio = findTrio(regulars, laiziCount);
                if (trio) return { type: PLAY_TYPE.TRIO, value: trio.value, cards: sortedCards, length: 3 };
            }

            // 查找对子 (2张)
            if (len === 2) {
                const pair = findPair(regulars, laiziCount);
                if (pair) return { type: PLAY_TYPE.PAIR, value: pair.value, cards: sortedCards, length: 2 };
            }
            
            // 查找单张 (1张)
            if (len === 1) {
                const value = sortedCards[0].value;
                return { type: PLAY_TYPE.SINGLE, value: value, cards: sortedCards, length: 1 };
            }

            return { type: PLAY_TYPE.INVALID };
        }
        
        // --- 牌型查找辅助函数 (新) ---

        function findBomb(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 4) return null;
            if (regulars.length === 0) return { value: 3 }; // 4个癞子当 炸弹3

            const valueCounts = {};
            regulars.forEach(c => { valueCounts[c.value] = (valueCounts[c.value] || 0) + 1; });
            
            for (const value in valueCounts) {
                if (valueCounts[value] + laiziCount >= 4) {
                    return { value: parseInt(value, 10) };
                }
            }
            return null; // 无法组成炸弹
        }

        function findFullHouse(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 5) return null;
            if (regulars.length <= 1) return { value: 3 }; // 纯癞子三带二, 算 33344

            const valueCounts = {};
            regulars.forEach(c => { valueCounts[c.value] = (valueCounts[c.value] || 0) + 1; });
            const uniqueValues = Object.keys(valueCounts).map(Number);
            
            if (uniqueValues.length === 1) { // e.g., [4, 4] + 3 laizi -> 444xx
                return { value: uniqueValues[0] };
            }
            
            if (uniqueValues.length === 2) {
                const val1 = uniqueValues[0];
                const count1 = valueCounts[val1];
                const val2 = uniqueValues[1];
                const count2 = valueCounts[val2];
                
                // 检查 [val1]AAA + [val2]BB
                let neededForTrio = 3 - count1;
                let neededForPair = 2 - count2;
                if (neededForTrio >= 0 && neededForPair >= 0 && neededForTrio + neededForPair <= laiziCount) {
                    return { value: val1 };
                }
                
                // 检查 [val1]AA + [val2]BBB
                neededForTrio = 3 - count2;
                neededForPair = 2 - count1;
                if (neededForTrio >= 0 && neededForPair >= 0 && neededForTrio + neededForPair <= laiziCount) {
                    return { value: val2 };
                }
            }
            return null;
        }
        
        function findStraight(regulars, laiziCount, totalLength) {
            if (regulars.length === 0) { // 纯癞子顺子
                return { value: 3 + totalLength - 1 }; // 算 3,4,5...
            }
            
            const uniqueValues = [...new Set(regulars.map(c => c.value))];
            uniqueValues.sort((a, b) => a - b);
            
            // 顺子不能包含 2 (15) 或王
            if (uniqueValues.some(v => v >= LAIZI_2_VALUE)) return null; 
            
            const minVal = uniqueValues[0];
            const maxVal = minVal + totalLength - 1;
            
            // 顺子不能到 2 (15) 或王
            if (maxVal >= LAIZI_2_VALUE) return null;

            let neededLaizi = 0;
            for (let i = 0; i < totalLength; i++) {
                const targetVal = minVal + i;
                if (!uniqueValues.includes(targetVal)) {
                    neededLaizi++;
                }
            }
            
            if (neededLaizi <= laiziCount) {
                return { value: maxVal }; // 顺子的大小看最大的牌
            }
            return null;
        }
        
        function findTrio(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 3) return null;
            if (regulars.length === 0) return { value: 3 }; // 3个癞子当 333
            
            const firstVal = regulars[0].value;
            if (regulars.every(c => c.value === firstVal)) {
                return { value: firstVal };
            }
            return null;
        }

        function findPair(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 2) return null;
            if (regulars.length === 0) return { value: 3 }; // 2个癞子当 33
            
            const firstVal = regulars[0].value;
            if (regulars.every(c => c.value === firstVal)) {
                return { value: firstVal };
            }
            return null;
        }


        /**
         * 检查出牌是否有效
         */
        function isValidPlay(playInfo, lastPlay, isNewRound) {
            if (playInfo.type === PLAY_TYPE.INVALID) return false;
            
            // 1. 自由出牌
            if (isNewRound) return true;

            // 2. 王炸逻辑
            if (playInfo.type === PLAY_TYPE.ROCKET) return true; // 王炸最大
            if (lastPlay.type === PLAY_TYPE.ROCKET) return false; // 王炸不能被压

            // 3. 炸弹逻辑
            if (playInfo.type === PLAY_TYPE.BOMB) {
                if (lastPlay.type === PLAY_TYPE.BOMB) {
                    return playInfo.value > lastPlay.value; // 炸弹比大小
                }
                return true; // 炸弹可以压任何非炸弹/王炸
            }
            
            // 4. 上家是炸弹
            if (lastPlay.type === PLAY_TYPE.BOMB) {
                return false; // 只有炸弹/王炸能压
            }

            // 5. 跟牌：牌型和长度必须一致
            if (playInfo.type !== lastPlay.type) return false;
            if (playInfo.length !== lastPlay.length) return false;
            
            // 6. 比大小
            return playInfo.value > lastPlay.value;
        }

        // --- 启动 ---
        initFirebase();

    </script>
</body>
</html>