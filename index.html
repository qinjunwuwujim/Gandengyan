<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¹²çªçœ¼ (æœ€ç»ˆç‰ˆ-v2)</title>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* è‡ªå®šä¹‰æ ·å¼ */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
            overscroll-behavior: none;
            background-color: #1F2937; /* gray-800 */
        }
        
        /* éšè—æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { display: none; }

        /* (æ–°) ç‰¹æ•ˆ */
        #effect-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            font-size: 8rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 10px #FCD34D, 0 0 20px #FCD34D, 0 0 30px #EF4444, 0 0 40px #EF4444;
            animation: effect-fade-in-out 2s ease-in-out forwards;
        }

        @keyframes effect-fade-in-out {
            0% { opacity: 0; transform: scale(0.5); }
            25% { opacity: 1; transform: scale(1.2); }
            75% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.5); }
        }


        /* æ¸¸æˆç•Œé¢ */
        #game-board {
            display: grid;
            grid-template-rows: 1fr 2fr 1fr; /* ä¸Šã€ä¸­ã€ä¸‹ */
            grid-template-columns: 1fr 3fr 1fr; /* å·¦ã€ä¸­ã€å³ */
            height: 100vh;
            width: 100vw;
            padding: 1rem;
            box-sizing: border-box;
            gap: 1rem;
        }

        /* ç©å®¶ä½ç½® */
        #player-area-top { grid-area: 1 / 2 / 2 / 3; flex-direction: column-reverse; } 
        #player-area-left { grid-area: 2 / 1 / 3 / 2; flex-direction: row-reverse; } 
        #player-area-right { grid-area: 2 / 3 / 3 / 4; } 
        #player-area-bottom { grid-area: 3 / 2 / 4 / 3; flex-direction: column; } 
        #table-area { grid-area: 2 / 2 / 3 / 3; }

        .player-area {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }
        
        .player-area.active {
            border-color: #FCD34D; /* yellow-300 */
            box-shadow: 0 0 15px rgba(252, 211, 77, 0.3);
        }
        
        .player-area.drawing {
            border-color: #3B82F6; /* blue-500 */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
        }

        .player-info {
            position: absolute;
            background: rgba(0,0,0,0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: white;
            z-index: 10;
        }

        /* è°ƒæ•´ä¸åŒä½ç½®çš„ä¿¡æ¯æ˜¾ç¤º */
        #player-area-top .player-info { top: 0.5rem; } 
        #player-area-bottom .player-info { bottom: 0.5rem; } 
        #player-area-left .player-info { top: 0.5rem; }
        #player-area-right .player-info { top: 0.5rem; }

        .hand-container {
            display: flex;
            flex-wrap: wrap; /* å…è®¸æ¢è¡Œ */
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* ç©å®¶è‡ªå·±çš„æ‰‹ç‰ŒåŒºåŸŸ */
        #player-hand-area {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: auto; /* æ‰‹ç‰Œå¤šæ—¶å¯æ»‘åŠ¨ */
            padding: 0.5rem;
        }
        #player-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0; /* é˜²æ­¢æ‰‹ç‰Œè¢«å‹ç¼© */
        }
        
        /* å¡ç‰‡ */
        .card {
            width: 64px;
            height: 90px;
            border-radius: 6px;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 16px;
            font-weight: bold;
            position: relative;
            transition: all 0.2s ease-out;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden; 
        }
        .card.face-down {
            background-color: #3B82F6;
            background-image: linear-gradient(135deg, #60A5FA 25%, transparent 25%), linear-gradient(225deg, #60A5FA 25%, transparent 25%), linear-gradient(45deg, #60A5FA 25%, transparent 25%), linear-gradient(315deg, #60A5FA 25%, #3B82F6 25%);
            background-position: 8px 0, 8px 0, 0 0, 0 0;
            background-size: 16px 16px;
            background-repeat: repeat;
        }
        .card .rank { line-height: 1; padding: 4px; }
        .card .suit { font-size: 18px; line-height: 1; text-align: center; }
        .card .rank.bottom { padding: 4px; align-self: flex-end; transform: rotate(180deg); }
        .card[data-suit="â™¥"], .card[data-suit="â™¦"] { color: #EF4444; }
        .card[data-suit="â™ "], .card[data-suit="â™£"] { color: #1F2937; }
        
        .card.laizi {
            color: #1F2937; 
            border: 3px solid #FCD34D; 
            background-color: #FEF9C3; 
        }
        /* Joker SVG æ ·å¼ */
        .joker-svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }
         .joker-svg svg {
            width: 40px;
            height: 40px;
        }
        /* (æ–°) Joker æ–‡å­—æ ·å¼ */
        .joker-text {
            position: absolute;
            font-size: 10px;
            font-weight: bold;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            z-index: 2;
            line-height: 1;
        }
        .joker-text-left { left: 5px; top: 5px; }
        .joker-text-right { right: 5px; bottom: 5px; transform: rotate(180deg); }
        
        .card[data-value="17"] { color: #EF4444; } 
        .card[data-value="17"] .joker-text { color: #EF4444; }
        .card[data-value="16"] { color: #1F2937; } 
        .card[data-value="16"] .joker-text { color: #1F2937; }
        
        /* (æ–°) Pass å¡ç‰‡ */
        .card.pass-card {
            background-color: #6B7280;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 800;
            border: 2px solid #FCD34D;
        }


        /* ç©å®¶è‡ªå·±çš„æ‰‹ç‰Œ */
        #player-hand .card {
            cursor: pointer;
        }
        #player-hand .card.selected {
            transform: translateY(-15px);
            border: 3px solid #3B82F6; 
        }
        
        /* (æ–°) æ¡Œé¢ä¸­å¤® */
        #table-area {
            position: relative; 
            display: grid;
            grid-template-rows: 1fr auto 1fr;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            justify-items: center;
            gap: 4px; /* ç‰Œå †å’Œå‡ºç‰ŒåŒºä¹‹é—´çš„é—´è· */
        }
        #bet-info {
            position: absolute;
            top: 0;
            background: rgba(0,0,0,0.5);
            padding: 0.25rem 0.75rem;
            border-radius: 99px;
            font-weight: bold;
            color: #FCD34D;
            z-index: 10;
        }
        
        #draw-pile-container {
            grid-area: 2 / 2 / 3 / 3; /* (æ–°) æ”¾åœ¨ç½‘æ ¼ä¸­å¿ƒ */
            position: relative;
            width: 64px;
            height: 90px;
        }
        .deck-count {
            position: absolute;
            bottom: -20px;
            width: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.875rem;
            color: #D1D5DB;
            text-align: center;
        }
        
        /* ç©å®¶å‡ºç‰ŒåŒº */
        .last-play-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            min-height: 90px;
            min-width: 100px;
            gap: -20px;
            padding-left: 20px;
        }
        .last-play-area .card {
            margin-left: -20px;
            cursor: default;
        }
        
        /* (æ–°) å®šä½å‡ºç‰ŒåŒºåˆ°ç½‘æ ¼ */
        #last-play-area-top {
            grid-area: 1 / 2 / 2 / 3;
            align-content: flex-end; /* ç‰Œå †å åœ¨åº•éƒ¨ */
        }
        #last-play-area-bottom {
            grid-area: 3 / 2 / 4 / 3;
            align-content: flex-start; /* ç‰Œå †å åœ¨é¡¶éƒ¨ */
        }
        #last-play-area-left {
            grid-area: 2 / 1 / 3 / 2;
            justify-content: flex-end;
        }
        #last-play-area-right {
            grid-area: 2 / 3 / 3 / 4;
            justify-content: flex-start;
        }
        
        
        /* è¦†ç›–å±‚ (å¼¹çª—) */
        .overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 50;
            color: #1F2937;
        }
        .modal {
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        
        .config-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
            text-align: center;
        }
        .config-label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
            text-align: left;
            font-size: 0.875rem;
        }
        
        /* æŒ‰é’® */
        .btn {
            padding: 10px 20px;
            font-weight: bold;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s;
            cursor: pointer;
        }
        .btn:disabled {
            background-color: #6B7280 !important;
            opacity: 0.7;
            cursor: not-allowed;
        }
        .btn-green { background-color: #10B981; color: white; }
        .btn-green:hover { background-color: #059669; }
        .btn-blue { background-color: #3B82F6; color: white; }
        .btn-blue:hover { background-color: #2563EB; }
        .btn-red { background-color: #EF4444; color: white; }
        .btn-red:hover { background-color: #DC2626; }
        .btn-gray { background-color: #6B7280; color: white; }
        .btn-gray:hover { background-color: #4B5563; }
        
        /* æ¶ˆæ¯æç¤º */
        #message-area {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #FCD34D;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            z-index: 100;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        #message-area.show {
            opacity: 1;
        }
        
        /* æ¸¸æˆå†…é€€å‡ºæŒ‰é’® */
        #ingame-leave-btn {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 40;
        }
    </style>
</head>
<body class="text-white">

    <!-- (æ–°) ç‰¹æ•ˆå±‚ -->
    <div id="effect-overlay" style="opacity: 0;"></div>

    <!-- æ¸¸æˆä¸»ç•Œé¢ (é»˜è®¤éšè—) -->
    <div id="game-board" class="hidden">
        
        <button id="ingame-leave-btn" class="btn btn-red">è¿”å›å¤§å…</button>
        
        <div id="player-area-top" class="player-area hidden">
            <div id="player-info-top" class="player-info">ç©å®¶ 2 (0 å¼ )</div>
            <div id="player-hand-top" class="hand-container"></div>
        </div>
        
        <div id="player-area-left" class="player-area hidden">
            <div id="player-info-left" class="player-info">ç©å®¶ 1 (0 å¼ )</div>
            <div id="player-hand-left" class="hand-container"></div>
        </div>

        <div id="table-area">
            <div id="bet-info">åº•åˆ†: <span id="base-bet-display">100</span></div>
            
            <div id="draw-pile-container">
                <div class="card face-down"></div>
                <div id="draw-pile-count" class="deck-count">å‰©ä½™: 0</div>
            </div>
            
            <div id="last-play-area-top" class="last-play-area"></div>
            <div id="last-play-area-bottom" class="last-play-area"></div>
            <div id="last-play-area-left" class="last-play-area"></div>
            <div id="last-play-area-right" class="last-play-area"></div>
        </div>

        <div id="player-area-right" class="player-area hidden">
            <div id="player-info-right" class="player-info">ç©å®¶ 3 (0 å¼ )</div>
            <div id="player-hand-right" class="hand-container"></div>
        </div>
        
        <div id="player-area-bottom" class="player-area">
            <div id="player-info-bottom" class="player-info">ä½  (0 å¼ )</div>
            <div class="absolute bottom-2 right-2 flex gap-2 z-10">
                <button id="play-button" class="btn btn-green">å‡ºç‰Œ</button>
                <!-- (æ–°) æŒ‰é’®åˆ†ç¦» -->
                <button id="pass-button" class="btn btn-gray">è¿‡</button>
                <button id="draw-button" class="btn btn-blue hidden">æ‘¸ç‰Œ</button> 
            </div>
            <div id="player-hand-area">
                <div id="player-hand" class="hand-container">
                    <!-- ç©å®¶çš„ç‰Œ -->
                </div>
            </div>
        </div>
    </div>

    <!-- åŠ è½½ç•Œé¢ (é»˜è®¤æ˜¾ç¤º) -->
    <div id="loading-screen" class="overlay">
        <div class="modal">
            <h2 class="text-2xl font-bold mb-4">æ­£åœ¨è¿æ¥...</h2>
            <p id="loading-status">æ­£åœ¨è¿æ¥åˆ° Firebase å¹¶è¿›è¡Œèº«ä»½éªŒè¯...</p>
        </div>
    </div>
    
    <!-- å¤§å…ç•Œé¢ -->
    <div id="lobby-screen" class="overlay hidden">
        <div class="modal">
            <h2 class="text-2xl font-bold mb-4">å¹²çªçœ¼ (åœ¨çº¿ç‰ˆ)</h2>
            <p class="mb-2">ä½ çš„ç”¨æˆ· ID: <strong id="user-id-display" class="text-xs break-all"></strong></p>
            
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="initial-score-input" class="config-label">åˆå§‹ç§¯åˆ†:</label>
                    <input id="initial-score-input" type="number" value="10000" class="config-input">
                </div>
                <div>
                    <label for="base-bet-input" class="config-label">åŸºç¡€åº•åˆ†:</label>
                    <input id="base-bet-input" type="number" value="100" class="config-input">
                </div>
            </div>
            
            <div class="flex flex-col gap-4">
                <button id="create-room-btn" class="btn btn-green" disabled>åˆ›å»ºæˆ¿é—´</button>
                <hr>
                <input id="room-id-input" type="text" placeholder="è¾“å…¥æˆ¿é—´ ID æˆ–é‚€è¯·é“¾æ¥" class="p-2 border rounded text-center">
                <button id="join-room-btn" class="btn btn-blue" disabled>åŠ å…¥æˆ¿é—´</button>
            </div>
        </div>
    </div>
    
    <!-- ç­‰å¾…å®¤ç•Œé¢ -->
    <div id="waiting-room-screen" class="overlay hidden">
        <div class="modal">
            <h2 class="text-xl font-bold mb-4">ç­‰å¾…å®¤</h2>
            <p id="waiting-room-prompt" class="mb-2">åˆ†äº«è¿™ä¸ªã€é‚€è¯·é“¾æ¥ã€‘ç»™ä½ çš„æœ‹å‹:</p>
            <input id="room-id-display" type="text" readonly class="p-2 border rounded text-center w-full font-bold text-sm mb-4" onclick="this.select()">
            
            <h3 class="font-bold mb-2">å·²åŠ å…¥çš„ç©å®¶ (<span id="player-count">1</span>/4):</h3>
            <ul id="player-list" class="list-disc list-inside mb-4 text-left">
                <!-- ç©å®¶åˆ—è¡¨ -->
            </ul>
            
            <button id="start-game-btn" class="btn btn-green hidden">å¼€å§‹æ¸¸æˆ (2-4 äºº)</button>
            <button id="leave-room-btn" class="btn btn-red mt-2">ç¦»å¼€æˆ¿é—´</button>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
    <div id="game-over-modal" class="overlay hidden">
        <div class="modal">
            <h2 id="game-over-title" class="text-3xl font-bold mb-4">æ¸¸æˆç»“æŸ</h2>
            <p id="game-over-message" class="text-lg mb-6">ç©å®¶ 1 èµ¢äº†!</p>
            
            <div id="score-recap" class="mb-6 text-left">
                <!-- e.g. ç©å®¶A: 10000 (+1000) -->
            </div>
            
            <button id="back-to-lobby-btn" class="btn btn-red">è¿”å›å¤§å…</button>
            <button id="next-game-btn" class="btn btn-blue ml-2 hidden">ä¸‹ä¸€å±€ (ä»…æˆ¿ä¸»)</button>
        </div>
    </div>
    
    <!-- ç™å­é€‰æ‹©å¼¹çª— -->
    <div id="laizi-choice-modal" class="overlay hidden">
        <div class="modal">
            <h2 class="text-2xl font-bold mb-4">è¯·é€‰æ‹©ç™å­ç»„åˆ</h2>
            <p class="mb-4">æ£€æµ‹åˆ°å¤šç§å‡ºç‰Œå¯èƒ½:</p>
            <div id="laizi-choice-buttons" class="flex flex-col gap-3">
                <!-- æŒ‰é’®å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>
    
    <!-- æ¶ˆæ¯æç¤ºæ¡† -->
    <div id="message-area"></div>

    <!-- Firebase SDK -->
    <script type="module">
        // å¯¼å…¥ Firebase æ¨¡å—
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction, writeBatch, arrayUnion, arrayRemove, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- å…¨å±€å˜é‡ ---
        let db, auth;
        let userId, appId;
        let currentRoomId = null;
        let localHand = [];
        let selectedIndices = [];
        let gameUnsubscribe = null;
        let handUnsubscribe = null;
        let myPlayerIndex = 0; 
        let hostFinishTimeout = null; 
        let currentRoomData = null; 
        let possibleLaiziPlays = []; 

        // --- UI å…ƒç´  ---
        const loadingScreen = document.getElementById('loading-screen');
        const loadingStatus = document.getElementById('loading-status');
        const lobbyScreen = document.getElementById('lobby-screen');
        const waitingRoomScreen = document.getElementById('waiting-room-screen');
        const gameBoard = document.getElementById('game-board');
        const gameOverModal = document.getElementById('game-over-modal');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const playButton = document.getElementById('play-button');
        const passButton = document.getElementById('pass-button');
        const drawButton = document.getElementById('draw-button');
        const initialScoreInput = document.getElementById('initial-score-input');
        const baseBetInput = document.getElementById('base-bet-input');
        const laiziChoiceModal = document.getElementById('laizi-choice-modal');
        const laiziChoiceButtons = document.getElementById('laizi-choice-buttons');
        const effectOverlay = document.getElementById('effect-overlay');

        // --- ç‰Œå‹å®šä¹‰ ---
        const SUITS = ['â™¦', 'â™£', 'â™¥', 'â™ ']; // æ–¹ç‰‡(å°) -> é»‘æ¡ƒ(å¤§)
        const SUIT_VALUES = { 'â™¦': 1, 'â™£': 2, 'â™¥': 3, 'â™ ': 4 };
        const RANKS = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']; // 2 æ˜¯ç™å­
        const RANK_VALUES = {};
        RANKS.forEach((rank, index) => { RANK_VALUES[rank] = index + 3; }); // 3=3 ... A=14
        
        const LAIZI_2_VALUE = 15; // 2
        const SMALL_JOKER_VALUE = 16; // å°ç‹
        const BIG_JOKER_VALUE = 17; // å¤§ç‹
        const LAIZI_VALUES = [LAIZI_2_VALUE, SMALL_JOKER_VALUE, BIG_JOKER_VALUE];
        
        const PLAY_TYPE = {
            INVALID: 'INVALID', SINGLE: 'SINGLE', PAIR: 'PAIR', TRIO: 'TRIO',
            FULL_HOUSE: 'FULL_HOUSE', 
            STRAIGHT: 'STRAIGHT', 
            CONSECUTIVE_PAIRS: 'CONSECUTIVE_PAIRS', 
            BOMB: 'BOMB',
            ROCKET: 'ROCKET' 
        };

        // --- 1. åˆå§‹åŒ– Firebase ---
        
        async function initFirebase() {
            try {
                const firebaseConfig = {
                  apiKey: "AIzaSyCmSAI_ojtg7mEWQJ_hfZBWMTxy0nHh1nk",
                  authDomain: "gandengyan-32d4a.firebaseapp.com",
                  projectId: "gandengyan-32d4a",
                  storageBucket: "gandengyan-32d4a.firebasestorage.app",
                  messagingSenderId: "1088497241628",
                  appId: "1:1088497241628:web:f957fa04eb4152b26c59d9",
                  measurementId: "G-NNRVFGYEGZ"
                };
                
                appId = firebaseConfig.projectId; 

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, async (user) => {
                    if (!user) {
                        loadingStatus.textContent = "æ­£åœ¨ç™»å½•...";
                        try {
                            await signInAnonymously(auth);
                        } catch (authError) {
                            console.error("Auth Error:", authError);
                            throw new Error(`èº«ä»½éªŒè¯å¤±è´¥: ${authError.message}`);
                        }
                        return;
                    }
                    
                    userId = user.uid;
                    document.getElementById('user-id-display').textContent = userId;
                    createRoomBtn.disabled = false;
                    joinRoomBtn.disabled = false;

                    const params = new URLSearchParams(window.location.search);
                    const roomIdFromUrl = params.get('room');

                    if (roomIdFromUrl) {
                        showMessage(`æ­£åœ¨è‡ªåŠ¨åŠ å…¥æˆ¿é—´ ${roomIdFromUrl}...`);
                        document.getElementById('room-id-input').value = roomIdFromUrl;
                        await autoJoinRoom(roomIdFromUrl);
                    } else {
                        showScreen('lobby');
                    }
                });
                
            } catch (error) {
                console.error("Firebase Init Error:", error);
                loadingScreen.innerHTML = `<div class="modal"><h2 class="text-2xl font-bold mb-4 text-red-600">è¿æ¥å¤±è´¥</h2><p>${error.message}</p></div>`;
            }
        }
        
        function getRoomIdFromInput(input) {
            let roomId = input.trim().toUpperCase();
            try {
                const url = new URL(input);
                const roomParam = url.searchParams.get('room');
                if (roomParam) {
                    roomId = roomParam.toUpperCase();
                }
            } catch (e) {
                // Not a URL
            }
            return roomId;
        }

        async function autoJoinRoom(roomId) {
            joinRoomBtn.disabled = true; 
            
            const roomRef = doc(db, paths.room(roomId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) {
                        throw new Error("æˆ¿é—´ä¸å­˜åœ¨ (æ¥è‡ªé“¾æ¥)");
                    }
                    
                    const roomData = roomSnap.data();
                    if (roomData.status !== "waiting") {
                        if(roomData.status === "finished") {
                           // å…è®¸åŠ å…¥
                        } else {
                           throw new Error("æ¸¸æˆå·²å¼€å§‹ (æ¥è‡ªé“¾æ¥)");
                        }
                    }
                    
                    if (roomData.players.length >= 4 && !roomData.players.some(p => p.uid === userId)) {
                        throw new Error("æˆ¿é—´å·²æ»¡ (æ¥è‡ªé“¾æ¥)");
                    }
                    
                    if (!roomData.players.some(p => p.uid === userId)) {
                        const newPlayer = { 
                            uid: userId, 
                            name: `ç©å®¶ ${roomData.players.length + 1}`, 
                            cardCount: 0, 
                            score: roomData.initialScore || 10000 
                        };
                        transaction.update(roomRef, {
                            players: arrayUnion(newPlayer),
                            log: arrayUnion(`${newPlayer.name} å·²åŠ å…¥ã€‚`)
                        });
                    }
                });

                await joinRoom(roomId); 
                
            } catch (error) {
                console.error("Auto-join Error:", error);
                showMessage("è‡ªåŠ¨åŠ å…¥å¤±è´¥: " + error.message);
                joinRoomBtn.disabled = false;
                showScreen('lobby'); 
                window.history.pushState({}, '', window.location.pathname); 
            }
        }

        // --- 2. UI å±å¹•ç®¡ç† ---

        function showScreen(screenId) {
            loadingScreen.classList.add('hidden');
            lobbyScreen.classList.add('hidden');
            waitingRoomScreen.classList.add('hidden');
            gameBoard.classList.add('hidden');
            gameOverModal.classList.add('hidden');
            laiziChoiceModal.classList.add('hidden'); 
            
            if (screenId === 'waiting-room') {
                waitingRoomScreen.classList.remove('hidden');
                return;
            }

            const screenElement = document.getElementById(`${screenId}-screen`);
            if (screenElement) {
                screenElement.classList.remove('hidden');
            } else if (screenId === 'game-board') {
                 gameBoard.classList.remove('hidden');
            }
        }
        
        function showMessage(msg, duration = 2000) {
            const msgArea = document.getElementById('message-area');
            if (!msgArea) return; 
            msgArea.textContent = msg;
            msgArea.classList.add('show');
            setTimeout(() => msgArea.classList.remove('show'), duration);
        }

        // (æ–°) ç‰¹æ•ˆ
        function showEffect(text) {
            effectOverlay.textContent = text;
            effectOverlay.style.animation = 'none';
            effectOverlay.offsetHeight; /* è§¦å‘é‡ç»˜ */
            effectOverlay.style.animation = 'effect-fade-in-out 2s ease-in-out forwards';
        }

        // --- 3. è·¯å¾„åŠ©æ‰‹ ---
        const paths = {
            room: (roomId) => `/artifacts/${appId}/public/data/gandengyan-rooms/${roomId}`,
            hand: (roomId, uid) => `/artifacts/${appId}/public/data/gandengyan-hands/${roomId}-${uid}`
        };
        
        // --- 4. å¤§å…é€»è¾‘ (åˆ›å»º/åŠ å…¥) ---
        
        createRoomBtn.onclick = async () => {
            const btn = createRoomBtn;
            btn.disabled = true;
            btn.textContent = "åˆ›å»ºä¸­...";
            
            const initialScore = parseInt(initialScoreInput.value, 10) || 10000;
            const baseBet = parseInt(baseBetInput.value, 10) || 100;
            
            const roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            const roomRef = doc(db, paths.room(roomId));
            
            const initialRoomData = {
                roomId: roomId,
                hostId: userId,
                players: [{ 
                    uid: userId, 
                    name: `ç©å®¶ 1`, 
                    cardCount: 0, 
                    score: initialScore 
                }], 
                status: "waiting", // waiting, playing, drawing, finishing, finished
                drawPile: [],
                discardPile: [], 
                lastPlayedCards: [], 
                displayCards: [], 
                playerPlays: {}, 
                lastPlayerId: null, 
                currentPlay: null,
                currentPlayerIndex: 0,
                isNewRound: true,
                passMask: 0, // (æ–°) pass ä½æ©ç 
                drawMask: 0, // (æ–°) draw ä½æ©ç 
                log: [`æˆ¿é—´ ${roomId} å·²åˆ›å»ºã€‚`],
                winner: null,
                gameNumber: 1, 
                bombCount: 0,
                oldBombCount: 0,
                baseBet: baseBet,  
                initialScore: initialScore, 
                playHistory: [], 
                smallestCard: null, 
                smallestCardPlayerIndex: 0 
            };
            
            try {
                await setDoc(roomRef, initialRoomData);
                await joinRoom(roomId); 
            } catch (error) {
                console.error("Create Room Error:", error);
                showMessage("åˆ›å»ºæˆ¿é—´å¤±è´¥: " + error.message);
                btn.disabled = false;
            } finally {
                btn.textContent = "åˆ›å»ºæˆ¿é—´";
            }
        };

        joinRoomBtn.onclick = async () => {
            const inputVal = document.getElementById('room-id-input').value;
            const roomId = getRoomIdFromInput(inputVal); 
            
            if (!roomId) {
                 showMessage("è¯·è¾“å…¥æœ‰æ•ˆçš„æˆ¿é—´ ID æˆ–é‚€è¯·é“¾æ¥");
                 return;
            }
            
            const btn = joinRoomBtn;
            btn.disabled = true;
            
            const roomRef = doc(db, paths.room(roomId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) {
                        throw new Error("æˆ¿é—´ä¸å­˜åœ¨"); 
                    }
                    
                    const roomData = roomSnap.data();
                    if (roomData.status !== "waiting" && roomData.status !== "finished") {
                        throw new Error("æ¸¸æˆå·²å¼€å§‹æˆ–å·²ç»“æŸ");
                    }
                    
                    if (roomData.players.length >= 4 && !roomData.players.some(p => p.uid === userId)) {
                        throw new Error("æˆ¿é—´å·²æ»¡");
                    }
                    
                    if (!roomData.players.some(p => p.uid === userId)) {
                        const newPlayer = { 
                            uid: userId, 
                            name: `ç©å®¶ ${roomData.players.length + 1}`, 
                            cardCount: 0,
                            score: roomData.initialScore || 10000 
                        };
                        transaction.update(roomRef, {
                            players: arrayUnion(newPlayer),
                            log: arrayUnion(`${newPlayer.name} å·²åŠ å…¥ã€‚`)
                        });
                    }
                });

                await joinRoom(roomId); 
                
            } catch (error) {
                console.error("Join Room Error:", error);
                showMessage("åŠ å…¥å¤±è´¥: " + error.message);
                btn.disabled = false;
            }
        };

        // --- 5. ç­‰å¾…å®¤é€»è¾‘ ---
        
        async function joinRoom(roomId) {
            currentRoomId = roomId;
            
            if (gameUnsubscribe) gameUnsubscribe();
            if (handUnsubscribe) handUnsubscribe();

            const roomRef = doc(db, paths.room(roomId));
            gameUnsubscribe = onSnapshot(roomRef, (docSnap) => {
                if (!docSnap.exists()) {
                    if (currentRoomId) { 
                        showMessage("æˆ¿é—´ä¸å­˜åœ¨æˆ–å·²è§£æ•£");
                        leaveRoom(false);
                    }
                    return;
                }
                
                const oldStatus = currentRoomData ? currentRoomData.status : null;
                const oldBombCount = currentRoomData ? currentRoomData.bombCount : 0;
                currentRoomData = docSnap.data(); 
                
                // (æ–°) è§¦å‘ç‰¹æ•ˆ
                if ((oldStatus === "playing" || oldStatus === "drawing") && currentRoomData.bombCount > oldBombCount) {
                    if(currentRoomData.currentPlay && currentRoomData.currentPlay.type === PLAY_TYPE.ROCKET) {
                         showEffect("ç‹ç‚¸!! ğŸš€");
                    } else {
                         showEffect("BOMB!! ğŸ’£");
                    }
                }
                
                renderGameState(currentRoomData);
            }, (error) => {
                console.error("Room subscription error:", error);
                leaveRoom(false);
                showMessage("æˆ¿é—´è¿æ¥é”™è¯¯: " + error.message);
            });
            
            const handRef = doc(db, paths.hand(roomId, userId));
            handUnsubscribe = onSnapshot(handRef, (docSnap) => {
                if (docSnap.exists()) {
                    localHand = docSnap.data().cards;
                    renderPlayerHand();
                } else {
                    localHand = []; 
                    renderPlayerHand();
                }
            });

            const roomSnap = await getDoc(roomRef);
            if(roomSnap.exists()) {
                const status = roomSnap.data().status;
                if(status === "playing" || status === "finishing" || status === "drawing") {
                    showScreen('game-board');
                } else if (status === "finished") {
                    showScreen('game-board'); 
                    renderGameState(roomSnap.data()); 
                } else {
                    showScreen('waiting-room');
                }
            } else {
                 showScreen('lobby');
            }
        }
        
        document.getElementById('leave-room-btn').onclick = () => leaveRoom(true);
        document.getElementById('ingame-leave-btn').onclick = () => leaveRoom(true);
        document.getElementById('back-to-lobby-btn').onclick = () => leaveRoom(false); 

        async function leaveRoom(updateDB) {
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null; 
            }
            if (handUnsubscribe) {
                handUnsubscribe();
                handUnsubscribe = null; 
            }
            if (hostFinishTimeout) {
                clearTimeout(hostFinishTimeout);
                hostFinishTimeout = null;
            }
            
            const roomId = currentRoomId;
            const uid = userId;
            
            currentRoomId = null;
            localHand = [];
            selectedIndices = [];
            currentRoomData = null; 

            if (updateDB && roomId && uid) {
                const roomRef = doc(db, paths.room(roomId));
                const handRef = doc(db, paths.hand(roomId, uid));
                
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomSnap = await transaction.get(roomRef);
                        if (!roomSnap.exists()) return;
                        
                        const roomData = roomSnap.data();
                        
                        const newPlayers = roomData.players.filter(p => p.uid !== uid);
                        
                        if (newPlayers.length === 0 || roomData.status === "finished") {
                            transaction.delete(roomRef);
                        } else {
                            let newHostId = roomData.hostId;
                            if (roomData.hostId === uid) {
                                newHostId = newPlayers[0].uid;
                            }
                            transaction.update(roomRef, {
                                players: newPlayers,
                                hostId: newHostId,
                                log: arrayUnion(`ç©å®¶ ${uid.substring(0,4)} å·²ç¦»å¼€ã€‚`)
                            });
                        }
                        transaction.delete(handRef);
                    });
                } catch (error) {
                    console.error("Leave Room Error:", error);
                }
            }
            
            showScreen('lobby');
            window.history.pushState({}, '', window.location.pathname);
        }

        // --- 6. æ¸²æŸ“æ¸¸æˆçŠ¶æ€ (æ ¸å¿ƒ) ---
        
        function renderGameState(roomData) {
            if (!roomData || !currentRoomId) return;
            
            if (hostFinishTimeout) {
                clearTimeout(hostFinishTimeout);
                hostFinishTimeout = null;
            }

            if (roomData.status === "waiting") {
                showScreen('waiting-room');
                const inviteLink = `${window.location.origin}${window.location.pathname}?room=${roomData.roomId}`;
                document.getElementById('room-id-display').value = inviteLink;
                
                const playerList = document.getElementById('player-list');
                playerList.innerHTML = '';
                roomData.players.forEach(p => {
                    const li = document.createElement('li');
                    li.textContent = `${p.name} (ç§¯åˆ†: ${p.score}) ${p.uid === roomData.hostId ? '(æˆ¿ä¸»)' : ''} ${p.uid === userId ? '(ä½ )' : ''}`;
                    playerList.appendChild(li);
                });
                document.getElementById('player-count').textContent = roomData.players.length;
                
                const startBtn = document.getElementById('start-game-btn');
                if (roomData.hostId === userId && roomData.players.length >= 2) {
                    startBtn.classList.remove('hidden');
                    startBtn.textContent = `å¼€å§‹æ¸¸æˆ (${roomData.players.length} äºº)`;
                } else {
                    startBtn.classList.add('hidden');
                }
                
            } else if (roomData.status === "playing" || roomData.status === "finishing" || roomData.status === "drawing") {
                if (window.location.search.includes('room=')) {
                    window.history.pushState({}, '', window.location.pathname);
                }
                showScreen('game-board');
                
                const numPlayers = roomData.players.length;
                myPlayerIndex = roomData.players.findIndex(p => p.uid === userId);
                if (myPlayerIndex === -1) {
                    // æ—è§‚
                }
                
                const areas = [
                    { id: 'bottom', handEl: 'player-hand-area', infoEl: 'player-info-bottom', areaEl: 'player-area-bottom', playAreaEl: 'last-play-area-bottom' },
                    { id: 'left',   handEl: 'player-hand-left', infoEl: 'player-info-left', areaEl: 'player-area-left', playAreaEl: 'last-play-area-left' }, 
                    { id: 'top',    handEl: 'player-hand-top', infoEl: 'player-info-top', areaEl: 'player-area-top', playAreaEl: 'last-play-area-top' }, 
                    { id: 'right',  handEl: 'player-hand-right', infoEl: 'player-info-right', areaEl: 'player-area-right', playAreaEl: 'last-play-area-right' }
                ];
                
                areas.forEach(a => document.getElementById(a.areaEl).classList.add('hidden'));

                let displayMap = [];
                if (numPlayers === 2) {
                    displayMap[0] = areas[0]; // æˆ‘
                    displayMap[1] = areas[2]; // å¯¹é¢
                } else if (numPlayers === 3) {
                    displayMap[0] = areas[0]; // æˆ‘
                    displayMap[1] = areas[1]; // å·¦
                    displayMap[2] = areas[3]; // å³
                } else {
                    displayMap[0] = areas[0];
                    displayMap[1] = areas[1];
                    displayMap[2] = areas[2];
                    displayMap[3] = areas[3];
                }
                
                areas.forEach(a => {
                    const playAreaEl = document.getElementById(a.playAreaEl);
                    if (playAreaEl) playAreaEl.innerHTML = '';
                });

                for (let i = 0; i < numPlayers; i++) {
                    const player = roomData.players[i];
                    const relativeIndex = (i - myPlayerIndex + numPlayers) % numPlayers;
                    
                    const area = displayMap[relativeIndex];
                    if (!area) continue; 

                    const areaEl = document.getElementById(area.areaEl);
                    const infoEl = document.getElementById(area.infoEl);
                    const handEl = document.getElementById(area.handEl);
                    
                    areaEl.classList.remove('hidden'); 
                    infoEl.textContent = `${player.name} (${player.cardCount} å¼ ) | ${player.score} åˆ†`; 
                    
                    areaEl.classList.remove('active', 'drawing');
                    if (i === roomData.currentPlayerIndex) {
                        if (roomData.status === 'drawing') {
                            areaEl.classList.add('drawing');
                        } else {
                            areaEl.classList.add('active');
                        }
                    }

                    const playAreaEl = document.getElementById(area.playAreaEl);
                    const playerPlay = roomData.playerPlays ? roomData.playerPlays[player.uid] : null;
                    if (playerPlay && playerPlay.displayCards) {
                        playerPlay.displayCards.forEach(card => {
                            playAreaEl.appendChild(createCardElement(card));
                        });
                    } else if (playerPlay && playerPlay.passed) {
                         // (æ–°) æ˜¾ç¤º PASS
                        const passCard = document.createElement('div');
                        passCard.className = 'card pass-card';
                        passCard.textContent = 'PASS';
                        playAreaEl.appendChild(passCard);
                    }

                    if (relativeIndex !== 0) { 
                        const handContainer = document.getElementById(area.handEl);
                        handContainer.innerHTML = '';
                        if (player.cardCount > 0) {
                            handContainer.appendChild(createCardElement(null, true)); 
                        }
                    }
                }
                
                document.getElementById('draw-pile-count').textContent = `å‰©ä½™: ${roomData.drawPile.length + roomData.discardPile.length}`;
                const realBaseBet = (roomData.baseBet || 100) * Math.pow(2, roomData.bombCount || 0);
                document.getElementById('base-bet-display').textContent = realBaseBet; 
                
                const isMyTurn = roomData.currentPlayerIndex === myPlayerIndex;
                
                if (roomData.status === "finishing") {
                    playButton.disabled = true;
                    passButton.disabled = true;
                    drawButton.classList.add('hidden');
                    const winnerName = roomData.players.find(p => p.uid === roomData.winner)?.name || "??";
                    showMessage(`${winnerName} èµ¢äº†! 5ç§’åç»“ç®—...`, 4500);

                    if (roomData.hostId === userId) {
                        hostFinishTimeout = setTimeout(() => {
                            calculateAndFinishGame(roomData);
                        }, 5000); 
                    }
                    return; 
                }
                
                // (æ–°) æ‘¸ç‰Œé˜¶æ®µ
                if (roomData.status === "drawing") {
                    playButton.disabled = true;
                    passButton.disabled = true;
                    
                    const myDrawBit = 1 << myPlayerIndex;
                    const hasDrawn = (roomData.drawMask & myDrawBit) > 0;
                    
                    if (isMyTurn && !hasDrawn) {
                        drawButton.classList.remove('hidden');
                        drawButton.disabled = false;
                        const drawnCount = (roomData.drawMask.toString(2).match(/1/g) || []).length;
                        drawButton.textContent = `æ‘¸ç‰Œ (${drawnCount + 1}/${numPlayers})`;
                    } else {
                        drawButton.classList.add('hidden');
                        drawButton.disabled = true;
                    }
                } 
                // (æ–°) å‡ºç‰Œé˜¶æ®µ
                else if (roomData.status === "playing") {
                    drawButton.classList.add('hidden');
                    
                    if (isMyTurn) {
                        playButton.disabled = false;
                        passButton.disabled = false;
                    } else {
                        playButton.disabled = true;
                        passButton.disabled = true;
                    }
                    
                    // (æ–°) æ–°å›åˆå¿…é¡»å‡ºç‰Œ, ä¸èƒ½"è¿‡"
                    if (isMyTurn && roomData.isNewRound) {
                        passButton.disabled = true;
                    }
                }


            } else if (roomData.status === "finished") {
                const scoreRecapEl = document.getElementById('score-recap');
                scoreRecapEl.innerHTML = '';
                
                const oldScores = (roomData.oldPlayers || roomData.players).reduce((acc, p) => {
                   acc[p.uid] = p.score;
                   return acc;
                }, {});

                roomData.players.forEach(p => {
                    const oldScore = oldScores[p.uid] || p.score;
                    const scoreChange = p.score - oldScore;
                    const pEl = document.createElement('p');
                    
                    if (scoreChange > 0) {
                        pEl.textContent = `${p.name}: ${p.score} ( +${scoreChange} )`;
                        pEl.classList.add('font-bold', 'text-green-600');
                    } else if (scoreChange < 0) {
                        pEl.textContent = `${p.name}: ${p.score} ( ${scoreChange} )`;
                        pEl.classList.add('text-red-600');
                    } else {
                        pEl.textContent = `${p.name}: ${p.score} ( 0 )`;
                    }
                    scoreRecapEl.appendChild(pEl);
                });

                document.getElementById('game-over-title').textContent = roomData.winner === userId ? "æ­å–œä½ ï¼" : "å¾ˆé—æ†¾...";
                const winnerName = roomData.players.find(p => p.uid === roomData.winner)?.name || "??";
                document.getElementById('game-over-message').textContent = `${winnerName} èµ¢å¾—äº†æ¸¸æˆ (ç¬¬ ${roomData.gameNumber || 1} å±€)!`;
                gameOverModal.classList.remove('hidden');
                
                const nextGameBtn = document.getElementById('next-game-btn');
                if (roomData.hostId === userId) {
                    nextGameBtn.classList.remove('hidden');
                    nextGameBtn.onclick = () => startNextGame(roomData);
                } else {
                    nextGameBtn.classList.add('hidden');
                }
            }
        }
        
        // --- 7. æ¸²æŸ“ç©å®¶æ‰‹ç‰Œ (è‡ªå·±) ---
        
        function renderPlayerHand() {
            const playerHandArea = document.getElementById('player-hand');
            if (!playerHandArea) return; 
            
            playerHandArea.innerHTML = '';
            localHand.sort((a, b) => {
                const aIsLaizi = LAIZI_VALUES.includes(a.value);
                const bIsLaizi = LAIZI_VALUES.includes(b.value);
                
                if (aIsLaizi && !bIsLaizi) return 1;
                if (!aIsLaizi && bIsLaizi) return -1;

                const suitScoreA = a.suit ? SUIT_VALUES[a.suit] : (a.value === 16 ? 1 : 2);
                const suitScoreB = b.suit ? SUIT_VALUES[b.suit] : (b.value === 16 ? 1 : 2);
                
                return a.value - b.value || suitScoreA - suitScoreB;
            });
            
            localHand.forEach((card, index) => {
                const cardDiv = createCardElement(card);
                if (selectedIndices.includes(index)) {
                    cardDiv.classList.add('selected');
                }
                cardDiv.addEventListener('click', () => toggleCardSelection(index));
                playerHandArea.appendChild(cardDiv);
            });
            
            const infoBottom = document.getElementById('player-info-bottom');
            if (infoBottom && infoBottom.textContent) {
                const nameAndScore = infoBottom.textContent.split('(')[0] || 'ä½ ';
                infoBottom.textContent = `${nameAndScore}(${localHand.length} å¼ )`;
            }
        }

        function createCardElement(card, isFaceDown = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            
            if (isFaceDown) {
                cardDiv.classList.add('face-down');
            } else {
                cardDiv.dataset.value = card.value;
                
                if (card.isLaiziSub) {
                    cardDiv.classList.add('laizi');
                } 
                else if (LAIZI_VALUES.includes(card.value)) {
                    cardDiv.classList.add('laizi');
                }

                if (card.value === BIG_JOKER_VALUE) {
                    // (æ–°) SVG å¤§ç‹ (ç§»é™¤ J)
                    cardDiv.innerHTML = `
                        <div class="joker-text joker-text-left" style="color: #EF4444;">JOKER</div>
                        <div class="joker-svg">
                           <svg viewBox="-2 -2 24 24" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet" fill="none"><path d="M10 20C15.5228 20 20 15.5228 20 10C20 4.47715 15.5228 0 10 0C4.47715 0 0 4.47715 0 10C0 15.5228 4.47715 20 10 20Z" fill="#FFD700"></path><path d="M10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 14.4183 5.58172 18 10 18Z" fill="#F7B239"></path><path d="M10 16C13.3137 16 16 13.3137 16 10C16 6.68629 13.3137 4 10 4C6.68629 4 4 6.68629 4 10C4 13.3137 6.68629 16 10 16Z" fill="#FFFFFF"></path><path d="M14 10C14 12.2091 12.2091 14 10 14C7.79086 14 6 12.2091 6 10C6 7.79086 7.79086 6 10 6C12.2091 6 14 7.79086 14 10Z" fill="#FBD248"></path><path d="M10 4C10.42 4 10.82 4.07 11.2 4.2C11.13 3.62 10.96 3.06 10.72 2.54C10.48 2.2 10.25 1.88 10 1.58C9.75 1.88 9.52 2.2 9.28 2.54C9.04 3.06 8.87 3.62 8.8 4.2C9.18 4.07 9.58 4 10 4Z" fill="#EF4444"></path><path d="M7 6C7.32 6 7.62 6.13 7.85 6.35C7.45 6.17 7.02 6.04 6.57 5.96C6.12 5.88 5.67 5.84 5.21 5.84C4.1 5.84 3.06 6.13 2.18 6.66C2.52 6.38 2.89 6.16 3.3 6.02C3.89 5.84 4.53 5.75 5.21 5.75C5.83 5.75 6.42 5.84 7 6Z" fill="#3B82F6"></path><path d="M13 6C12.68 6 12.38 6.13 12.15 6.35C12.55 6.17 12.98 6.04 13.43 5.96C13.88 5.88 14.33 5.84 14.79 5.84C15.9 5.84 16.94 6.13 17.82 6.66C17.48 6.38 17.11 6.16 16.7 6.02C16.11 5.84 15.47 5.75 14.79 5.75C14.17 5.75 13.58 5.84 13 6Z" fill="#3B82F6"></path><path d="M11 11C11 11.5523 10.5523 12 10 12C9.44772 12 9 11.5523 9 11C9 10.4477 9.44772 10 10 10C10.5523 10 11 10.4477 11 11Z" fill="#EF4444"></path><path d="M15 10C15 10.5523 14.5523 11 14 11C13.4477 11 13 10.5523 13 10C13 9.44772 13.4477 9 14 9C14.5523 9 15 9.44772 15 10Z" fill="#1F2937"></path><path d="M7 10C7 10.5523 6.55228 11 6 11C5.44772 11 5 10.5523 5 10C5 9.44772 5.44772 9 6 9C6.55228 9 7 9.44772 7 10Z" fill="#1F2937"></path></svg>
                        </div>
                        <div class="joker-text joker-text-right" style="color: #EF4444;">JOKER</div>`;
                } else if (card.value === SMALL_JOKER_VALUE) {
                    // (æ–°) SVG å°ç‹ (ç§»é™¤ J)
                    cardDiv.innerHTML = `
                        <div class="joker-text joker-text-left">JOKER</div>
                        <div class="joker-svg">
                            <svg viewBox="-2 -2 24 24" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet" fill="none"><path d="M10 20C15.5228 20 20 15.5228 20 10C20 4.47715 15.5228 0 10 0C4.47715 0 0 4.47715 0 10C0 15.5228 4.47715 20 10 20Z" fill="#6B7280"></path><path d="M10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 14.4183 5.58172 18 10 18Z" fill="#4B5563"></path><path d="M10 16C13.3137 16 16 13.3137 16 10C16 6.68629 13.3137 4 10 4C6.68629 4 4 6.68629 4 10C4 13.3137 6.68629 16 10 16Z" fill="#FFFFFF"></path><path d="M14 10C14 12.2091 12.2091 14 10 14C7.79086 14 6 12.2091 6 10C6 7.79086 7.79086 6 10 6C12.2091 6 14 7.79086 14 10Z" fill="#D1D5DB"></path><path d="M10 4C10.42 4 10.82 4.07 11.2 4.2C11.13 3.62 10.96 3.06 10.72 2.54C10.48 2.2 10.25 1.88 10 1.58C9.75 1.88 9.52 2.2 9.28 2.54C9.04 3.06 8.87 3.62 8.8 4.2C9.18 4.07 9.58 4 10 4Z" fill="#1F2937"></path><path d="M7 6C7.32 6 7.62 6.13 7.85 6.35C7.45 6.17 7.02 6.04 6.57 5.96C6.12 5.88 5.67 5.84 5.21 5.84C4.1 5.84 3.06 6.13 2.18 6.66C2.52 6.38 2.89 6.16 3.3 6.02C3.89 5.84 4.53 5.75 5.21 5.75C5.83 5.75 6.42 5.84 7 6Z" fill="#1F2937"></path><path d="M13 6C12.68 6 12.38 6.13 12.15 6.35C12.55 6.17 12.98 6.04 13.43 5.96C13.88 5.88 14.33 5.84 14.79 5.84C15.9 5.84 16.94 6.13 17.82 6.66C17.48 6.38 17.11 6.16 16.7 6.02C16.11 5.84 15.47 5.75 14.79 5.75C14.17 5.75 13.58 5.84 13 6Z" fill="#1F2937"></path><path d="M11 11C11 11.5523 10.5523 12 10 12C9.44772 12 9 11.5523 9 11C9 10.4477 9.44772 10 10 10C10.5523 10 11 10.4477 11 11Z" fill="#1F2937"></path><path d="M15 10C15 10.5523 14.5523 11 14 11C13.4477 11 13 10.5523 13 10C13 9.44772 13.4477 9 14 9C14.5523 9 15 9.44772 15 10Z" fill="#1F2937"></path><path d="M7 10C7 10.5523 6.55228 11 6 11C5.44772 11 5 10.5523 5 10C5 9.44772 5.44772 9 6 9C6.55228 9 7 9.44772 7 10Z" fill="#1F2937"></path></svg>
                        </div>
                        <div class="joker-text joker-text-right">JOKER</div>`;
                } else {
                    cardDiv.dataset.suit = card.suit;
                    cardDiv.innerHTML = `
                        <div class="rank">${card.rank}</div>
                        <div class="suit">${card.suit}</div>
                        <div class="rank bottom">${card.rank}</div>
                    `;
                }
            }
            return cardDiv;
        }

        function toggleCardSelection(index) {
            const selIndex = selectedIndices.indexOf(index);
            if (selIndex > -1) {
                selectedIndices.splice(selIndex, 1);
            } else {
                selectedIndices.push(index);
            }
            renderPlayerHand();
        }
        
        // --- 8. æ¸¸æˆé€»è¾‘ (å¼€å§‹/å‡ºç‰Œ/æ‘¸ç‰Œ) ---
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        async function startNextGame(roomData) {
            if (roomData.hostId !== userId) return;
            
            const players = roomData.players;
            const numPlayers = players.length;

            let deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) { deck.push({ suit, rank, value: RANK_VALUES[rank] }); }
                // (ä¿®å¤) '2' åº”è¯¥å¸¦èŠ±è‰²
                for (const suit of SUITS) {
                    deck.push({ suit: suit, rank: '2', value: LAIZI_2_VALUE }); 
                }
            }
            deck.push({ suit: 'Joker', rank: 'Small', value: SMALL_JOKER_VALUE });
            deck.push({ suit: 'Joker', rank: 'Big', value: BIG_JOKER_VALUE });
            
            deck = shuffleArray(deck);
            
            const hands = [];
            for (let i = 0; i < numPlayers; i++) hands.push([]);
            
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < numPlayers; j++) {
                    if (deck.length > 0) {
                        const card = deck.pop();
                        hands[j].push(card);
                    }
                }
            }
            
            let smallestValue = 99;
            let largestSuitScore = -1;
            let firstPlayerIndex = 0;
            let smallestCard = null;

            hands.forEach((hand) => {
                hand.forEach(card => {
                    if (!LAIZI_VALUES.includes(card.value) && card.value < smallestValue) {
                        smallestValue = card.value;
                    }
                });
            });

            hands.forEach((hand, playerIndex) => {
                hand.forEach(card => {
                    if (card.value === smallestValue) {
                        const suitScore = SUIT_VALUES[card.suit];
                        if (suitScore > largestSuitScore) {
                            largestSuitScore = suitScore;
                            firstPlayerIndex = playerIndex;
                            smallestCard = card;
                        }
                    }
                });
            });
            
            try {
                const batch = writeBatch(db);
                
                for (let i = 0; i < numPlayers; i++) {
                    const uid = players[i].uid;
                    const handRef = doc(db, paths.hand(currentRoomId, uid));
                    batch.set(handRef, { cards: hands[i] });
                }
                
                const updatedPlayers = players.map(p => ({ 
                    ...p, 
                    cardCount: 5 
                }));
                
                batch.update(doc(db, paths.room(currentRoomId)), {
                    status: "playing",
                    drawPile: deck,
                    discardPile: [],
                    players: updatedPlayers,
                    currentPlayerIndex: firstPlayerIndex, 
                    smallestCardPlayerIndex: firstPlayerIndex, 
                    smallestCard: smallestCard,
                    isNewRound: true,
                    lastPlayedCards: [],
                    displayCards: [], 
                    playerPlays: {}, 
                    lastPlayerId: null, 
                    currentPlay: null,
                    passMask: 0, 
                    drawMask: 0, 
                    log: arrayUnion(`ç¬¬ ${ (roomData.gameNumber || 1) + 1 } å±€æ¸¸æˆå¼€å§‹ï¼`),
                    winner: null,
                    bombCount: 0,
                    oldBombCount: 0,
                    baseBet: roomData.baseBet, 
                    initialScore: roomData.initialScore, 
                    playHistory: [], 
                    gameNumber: (roomData.gameNumber || 1) + 1,
                    oldPlayers: roomData.players 
                });
                
                await batch.commit();
                
            } catch (error) {
                console.error("Start Next Game Error:", error);
                showMessage("å¼€å§‹æ–°æ¸¸æˆå¤±è´¥: " + error.message);
            }
        }
        
        async function calculateAndFinishGame(roomData) {
            if (roomData.hostId !== userId || roomData.status !== "finishing") {
                return; 
            }
            
            try {
                const baseBet = roomData.baseBet || 100;
                const winnerId = roomData.winner;
                
                const uniquePlayers = [...new Set(roomData.playHistory || [])];
                const isSpring = (uniquePlayers.length === 1 && uniquePlayers[0] === winnerId);
                
                const bombMultiplier = Math.pow(2, roomData.bombCount || 0);
                const springMultiplier = isSpring ? 2 : 1;
                const finalBet = baseBet * bombMultiplier * springMultiplier;
                
                if (isSpring) {
                    showEffect("æ˜¥å¤©!! ğŸŒ¸");
                }

                let totalGain = 0;
                const newScores = {};
                roomData.players.forEach(p => newScores[p.uid] = p.score); 

                roomData.players.forEach(p => {
                    if (p.uid !== winnerId) {
                        const loss = p.cardCount * finalBet;
                        newScores[p.uid] -= loss;
                        totalGain += loss;
                    }
                });
                
                newScores[winnerId] += totalGain;
                
                const updatedPlayers = roomData.players.map(p => ({ 
                    ...p, 
                    score: newScores[p.uid] 
                }));
                
                const roomRef = doc(db, paths.room(roomData.roomId));
                await updateDoc(roomRef, { 
                    status: "finished", 
                    players: updatedPlayers,
                    oldPlayers: roomData.players 
                });
                
            } catch (error) {
                console.error("Calculate Score Error:", error);
                const roomRef = doc(db, paths.room(roomData.roomId));
                await updateDoc(roomRef, { status: "finished" });
            }
        }

        document.getElementById('start-game-btn').onclick = async () => {
            if (!currentRoomId || !appId) return;
            
            const roomRef = doc(db, paths.room(currentRoomId));
            const roomSnap = await getDoc(roomRef);
            if (!roomSnap.exists()) return;
            const roomData = roomSnap.data();
            const players = roomData.players;
            const numPlayers = players.length;

            if (numPlayers < 2 || numPlayers > 4) {
                showMessage("å¿…é¡»æœ‰ 2-4 åç©å®¶æ‰èƒ½å¼€å§‹ã€‚");
                return;
            }
            
            let deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) { deck.push({ suit, rank, value: RANK_VALUES[rank] }); }
                // (ä¿®å¤) '2' åº”è¯¥å¸¦èŠ±è‰²
                for (const suit of SUITS) {
                    deck.push({ suit: suit, rank: '2', value: LAIZI_2_VALUE }); 
                }
            }
            deck.push({ suit: 'Joker', rank: 'Small', value: SMALL_JOKER_VALUE });
            deck.push({ suit: 'Joker', rank: 'Big', value: BIG_JOKER_VALUE });
            
            deck = shuffleArray(deck);
            
            const hands = [];
            for (let i = 0; i < numPlayers; i++) hands.push([]);
            
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < numPlayers; j++) {
                    if (deck.length > 0) {
                        const card = deck.pop();
                        hands[j].push(card);
                    }
                }
            }
            
            let smallestValue = 99;
            let largestSuitScore = -1;
            let firstPlayerIndex = 0;
            let smallestCard = null;

            hands.forEach((hand) => {
                hand.forEach(card => {
                    if (!LAIZI_VALUES.includes(card.value) && card.value < smallestValue) {
                        smallestValue = card.value;
                    }
                });
            });

            hands.forEach((hand, playerIndex) => {
                hand.forEach(card => {
                    if (card.value === smallestValue) {
                        const suitScore = SUIT_VALUES[card.suit];
                        if (suitScore > largestSuitScore) {
                            largestSuitScore = suitScore;
                            firstPlayerIndex = playerIndex;
                            smallestCard = card;
                        }
                    }
                });
            });
            
            try {
                const batch = writeBatch(db);
                
                for (let i = 0; i < numPlayers; i++) {
                    const uid = players[i].uid;
                    const handRef = doc(db, paths.hand(currentRoomId, uid));
                    batch.set(handRef, { cards: hands[i] });
                }
                
                const updatedPlayers = players.map(p => ({ ...p, cardCount: 5 }));
                
                batch.update(roomRef, {
                    status: "playing",
                    drawPile: deck,
                    discardPile: [], 
                    players: updatedPlayers,
                    currentPlayerIndex: firstPlayerIndex, 
                    smallestCardPlayerIndex: firstPlayerIndex, 
                    smallestCard: smallestCard, 
                    isNewRound: true,
                    lastPlayedCards: [],
                    displayCards: [], 
                    playerPlays: {}, 
                    lastPlayerId: null, 
                    currentPlay: null,
                    passMask: 0, 
                    drawMask: 0, 
                    log: arrayUnion(`æ¸¸æˆå¼€å§‹ï¼${players[firstPlayerIndex].name} (æœ‰${smallestCard.rank}${smallestCard.suit}) å…ˆå‡ºã€‚`),
                    bombCount: 0,
                    oldBombCount: 0,
                    baseBet: roomData.baseBet, 
                    initialScore: roomData.initialScore, 
                    playHistory: [], 
                    gameNumber: 1, 
                });
                
                await batch.commit();
                
            } catch (error) {
                console.error("Start Game Error:", error);
                showMessage("å¼€å§‹æ¸¸æˆå¤±è´¥: " + error.message);
            }
        };

        // (æ–°) ç™å­é€‰æ‹©å¼¹çª—
        function showLaiziChoice(plays, selectedCards, isGameStart, smallestCard) {
            possibleLaiziPlays = plays; // ç¼“å­˜
            laiziChoiceButtons.innerHTML = '';
            
            plays.forEach((play, index) => {
                const btn = document.createElement('button');
                btn.className = 'btn btn-blue';
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«æœ€å°ç‰Œ (å¦‚æœæ˜¯ç¬¬ä¸€å›åˆ)
                if (isGameStart) {
                    const smallestCardId = (smallestCard.suit || '') + smallestCard.rank;
                    const displayCards = getDisplayCards(selectedCards, play);
                    const displayCardIds = displayCards.map(c => (c.suit || '') + c.rank);
                    
                    if (!displayCardIds.includes(smallestCardId)) {
                        const playedCardIds = selectedCards.map(c => (c.suit || '') + c.rank);
                        if (!playedCardIds.includes(smallestCardId)) {
                             btn.disabled = true; // ç¦ç”¨ä¸åŒ…å«æœ€å°ç‰Œçš„é€‰é¡¹
                        }
                    }
                }

                btn.textContent = `ä½œä¸º ${getPlayDescription(play)} å‡ºç‰Œ`;
                btn.onclick = () => {
                    executePlay(play, selectedCards);
                    laiziChoiceModal.classList.add('hidden');
                };
                laiziChoiceButtons.appendChild(btn);
            });
            
            laiziChoiceModal.classList.remove('hidden');
        }

        playButton.onclick = async () => {
            if (selectedIndices.length === 0) {
                showMessage("è¯·é€‰æ‹©è¦å‡ºçš„ç‰Œ");
                return;
            }
            if (!currentRoomData || !currentRoomId) return;
            
            playButton.disabled = true; 

            const selectedCards = selectedIndices.map(i => localHand[i]).sort((a, b) => a.value - b.value);
            
            const roomData = currentRoomData; 
            const isGameStart = (roomData.lastPlayerId === null);
            const isFreePlay = isGameStart || roomData.isNewRound;
            
            const allPlays = findAllPossiblePlays(selectedCards);
            const validPlays = allPlays.filter(p => isValidPlay(p, roomData.currentPlay, isFreePlay));

            if (validPlays.length === 0) {
                showMessage("æ— æ•ˆçš„å‡ºç‰Œï¼");
                playButton.disabled = false; 
                return;
            }
            
            if (isGameStart && roomData.currentPlayerIndex === roomData.smallestCardPlayerIndex) {
                const smallestCard = roomData.smallestCard;
                const smallestCardId = (smallestCard.suit || '') + smallestCard.rank;
                const playedCardIds = selectedCards.map(c => (c.suit || '') + c.rank);
                
                if (!playedCardIds.includes(smallestCardId)) {
                     const validPlaysWithSmallest = validPlays.filter(play => {
                        const displayCards = getDisplayCards(selectedCards, play);
                        const displayCardIds = displayCards.map(c => (c.suit || '') + c.rank);
                        return displayCardIds.includes(smallestCardId);
                     });
                     
                     if (validPlaysWithSmallest.length === 0) {
                        showMessage(`ç¬¬ä¸€å›åˆå¿…é¡»åŒ…å«ä½ æœ€å°çš„ç‰Œ (${smallestCard.rank}${smallestCard.suit})ï¼`);
                        playButton.disabled = false;
                        return;
                     }
                     
                     if (validPlaysWithSmallest.length === 1) {
                         executePlay(validPlaysWithSmallest[0], selectedCards);
                     } else {
                         showLaiziChoice(validPlaysWithSmallest, selectedCards, isGameStart, smallestCard);
                     }
                     return;
                }
            }

            if (validPlays.length === 1) {
                executePlay(validPlays[0], selectedCards);
            } else {
                showLaiziChoice(validPlays, selectedCards, isGameStart, roomData.smallestCard);
            }
        };

        async function executePlay(playInfo, selectedCards) {
            if (!currentRoomId || !appId) return;
            
            const playedCardIds = selectedCards.map(c => (c.suit || '') + c.rank); 
            const roomRef = doc(db, paths.room(currentRoomId));
            const handRef = doc(db, paths.hand(currentRoomId, userId));

            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    const handSnap = await transaction.get(handRef);
                    
                    if (!roomSnap.exists() || !handSnap.exists()) throw new Error("æˆ¿é—´æˆ–æ‰‹ç‰Œä¸å­˜åœ¨");
                    
                    const roomData = roomSnap.data();
                    const handData = handSnap.data();
                    const numPlayers = roomData.players.length;
                    
                    if (roomData.status !== "playing") throw new Error("æ¸¸æˆæœªåœ¨è¿›è¡Œ");
                    if (roomData.players[roomData.currentPlayerIndex].uid !== userId) throw new Error("è¿˜æ²¡è½®åˆ°ä½ ");
                    
                    const isGameStart = (roomData.lastPlayerId === null);
                    const isFreePlay = isGameStart || roomData.isNewRound;
                    
                    let finalPlayInfo = playInfo;
                    const lastPlay = roomData.currentPlay;

                    if (!isFreePlay && 
                        lastPlay && 
                        playInfo.type === PLAY_TYPE.SINGLE &&
                        LAIZI_VALUES.includes(playInfo.value) &&
                        lastPlay.type === PLAY_TYPE.SINGLE &&
                        lastPlay.value < BIG_JOKER_VALUE)
                    {
                        finalPlayInfo = {
                            ...playInfo, 
                            value: lastPlay.value + 1 
                        };
                    }
                    
                    const displayCards = getDisplayCards(selectedCards, finalPlayInfo);
                    
                    let idsToRemove = [...playedCardIds];
                    const newHand = handData.cards.filter(card => {
                        const cardId = (card.suit || '') + card.rank;
                        const indexToRemove = idsToRemove.indexOf(cardId);
                        
                        if (indexToRemove > -1) {
                            idsToRemove.splice(indexToRemove, 1);
                            return false; 
                        } else {
                            return true; 
                        }
                    });

                    if (idsToRemove.length > 0) {
                        console.error("æ‰‹ç‰Œä¸åŒæ­¥! æ²¡æ‰¾åˆ°ç‰Œ:", idsToRemove);
                        throw new Error("å‡ºç‰Œå¤±è´¥ (æ‰‹ç‰Œä¸åŒæ­¥)");
                    }
                    
                    let newStatus = roomData.status;
                    let winner = null;
                    if (newHand.length === 0) {
                        newStatus = "finishing"; 
                        winner = userId;
                    }
                    
                    let newBombCount = roomData.bombCount || 0;
                    if (playInfo.type === PLAY_TYPE.BOMB || playInfo.type === PLAY_TYPE.ROCKET) {
                        newBombCount++;
                    }
                    
                    transaction.set(handRef, { cards: newHand });
                    
                    const newPlayerIndex = (roomData.currentPlayerIndex + 1) % numPlayers;
                    const updatedPlayers = [...roomData.players];
                    updatedPlayers[myPlayerIndex].cardCount = newHand.length;
                    
                    const newPlayerPlays = {};
                    newPlayerPlays[userId] = { displayCards: displayCards };

                    transaction.update(roomRef, {
                        lastPlayedCards: selectedCards,
                        displayCards: displayCards, 
                        playerPlays: newPlayerPlays,
                        discardPile: arrayUnion(...selectedCards), 
                        currentPlay: finalPlayInfo, 
                        lastPlayerId: userId, 
                        playHistory: arrayUnion(userId), 
                        isNewRound: false, 
                        passMask: 0, 
                        drawMask: 0, 
                        currentPlayerIndex: newPlayerIndex,
                        players: updatedPlayers,
                        status: newStatus,
                        winner: winner,
                        bombCount: newBombCount, 
                        oldBombCount: roomData.bombCount,
                        log: arrayUnion(`${roomData.players[myPlayerIndex].name} å‡ºç‰Œäº†ã€‚`)
                    });
                });
                
                selectedIndices = []; 
                
            } catch (error) {
                console.error("Execute Play Error:", error);
                showMessage(error.message);
                playButton.disabled = false; 
            }
        }
        
        passButton.onclick = async () => {
            if (!currentRoomId || !appId) return;
            passButton.disabled = true; 
            
            const roomRef = doc(db, paths.room(currentRoomId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    if (!roomSnap.exists()) throw new Error("æˆ¿é—´ä¸å­˜åœ¨");
                    
                    const roomData = roomSnap.data();
                    if (roomData.status !== "playing") throw new Error("æ¸¸æˆæœªåœ¨è¿›è¡Œ");
                    if (roomData.players[roomData.currentPlayerIndex].uid !== userId) throw new Error("è¿˜æ²¡è½®åˆ°ä½ ");
                    
                    const numPlayers = roomData.players.length;
                    const newPlayerIndex = (roomData.currentPlayerIndex + 1) % numPlayers;
                    const myPassBit = 1 << myPlayerIndex;
                    const newPassMask = (roomData.passMask || 0) | myPassBit;
                    
                    const newPlayerPlays = { ...roomData.playerPlays };
                    newPlayerPlays[userId] = { passed: true }; 

                    let allOthersPassed = true;
                    for(let i=0; i < numPlayers; i++) {
                        if (i === myPlayerIndex) continue;
                        if (roomData.players[i].uid === roomData.lastPlayerId) continue; 
                        
                        const playerBit = 1 << i;
                        if ((newPassMask & playerBit) === 0) {
                            allOthersPassed = false;
                            break;
                        }
                    }
                    
                    const nextPlayerIsLastPlayer = (roomData.lastPlayerId !== null && roomData.players[newPlayerIndex].uid === roomData.lastPlayerId);
                    
                    if (nextPlayerIsLastPlayer || (allOthersPassed && roomData.lastPlayerId !== null)) {
                        // (æ–°) è¿›å…¥æ‘¸ç‰Œé˜¶æ®µ
                        transaction.update(roomRef, {
                            status: "drawing",
                            currentPlayerIndex: roomData.lastPlayerId ? roomData.players.findIndex(p => p.uid === roomData.lastPlayerId) : 0, // ä»æœ€åå‡ºç‰Œè€…å¼€å§‹æ‘¸
                            passMask: 0,
                            drawMask: 0,
                            playerPlays: newPlayerPlays,
                            log: arrayUnion(`${roomData.players[myPlayerIndex].name} 'è¿‡'äº†ã€‚å›åˆç»“æŸï¼Œå¼€å§‹æ‘¸ç‰Œã€‚`)
                        });
                        
                    } else {
                        // (æ–°) ç»§ç»­ä¼ ç»™ä¸‹å®¶
                        transaction.update(roomRef, {
                            currentPlayerIndex: newPlayerIndex,
                            passMask: newPassMask,
                            playerPlays: newPlayerPlays,
                            log: arrayUnion(`${roomData.players[myPlayerIndex].name} 'è¿‡'äº†ã€‚`)
                        });
                    }
                });
                
                selectedIndices = [];
                
            } catch (error) {
                console.error("Pass Error:", error);
                passButton.disabled = false; 
            }
        };

        drawButton.onclick = async () => {
            if (!currentRoomId || !appId) return;
            drawButton.disabled = true; 
            
            const roomRef = doc(db, paths.room(currentRoomId));
            // (ä¿®å¤) å¿…é¡»è·å–å½“å‰ç©å®¶çš„æ‰‹ç‰Œ, è€Œä¸æ˜¯ "æˆ‘" çš„æ‰‹ç‰Œ
            const currentPlayerId = currentRoomData.players[currentRoomData.currentPlayerIndex].uid;
            const handRef = doc(db, paths.hand(currentRoomId, currentPlayerId));
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnap = await transaction.get(roomRef);
                    const handSnap = await transaction.get(handRef);
                    
                    if (!roomSnap.exists() || !handSnap.exists()) throw new Error("æˆ¿é—´æˆ–æ‰‹ç‰Œä¸å­˜åœ¨");
                    
                    const roomData = roomSnap.data();
                    if (roomData.status !== "drawing") throw new Error("ä¸åœ¨æ‘¸ç‰Œé˜¶æ®µ");
                    // (ä¿®å¤) æ£€æŸ¥ "æˆ‘" æ˜¯ä¸æ˜¯å½“å‰ç©å®¶
                    if (roomData.players[roomData.currentPlayerIndex].uid !== userId) throw new Error("è¿˜æ²¡è½®åˆ°ä½ æ‘¸ç‰Œ");
                    
                    const numPlayers = roomData.players.length;
                    const newHand = [...handSnap.data().cards]; // (ä¿®å¤) ä» handSnap è·å–
                    let newDrawPile = [...roomData.drawPile];
                    let newDiscardPile = [...roomData.discardPile];
                    let logMsg = "";
                    
                    let drawnCard = null;
                    if (newDrawPile.length > 0) {
                        drawnCard = newDrawPile.pop();
                    } else if (newDiscardPile.length > 0) {
                        newDrawPile = shuffleArray(newDiscardPile.filter(c => c)); 
                        newDiscardPile = [];
                        if (newDrawPile.length > 0) {
                           drawnCard = newDrawPile.pop();
                           logMsg = "(æ´—ç‰Œ)";
                        }
                    }
                    
                    if (drawnCard) {
                        newHand.push(drawnCard);
                    }
                    
                    transaction.set(handRef, { cards: newHand });
                    
                    const updatedPlayers = [...roomData.players];
                    // (ä¿®å¤) å¿…é¡»æ›´æ–°å½“å‰ç©å®¶çš„ç‰Œæ•°
                    updatedPlayers[roomData.currentPlayerIndex].cardCount = newHand.length;
                    
                    // (ä¿®å¤) ä½¿ç”¨ currentPlayerIndex æ¥è®¾ç½® bit
                    const currentPlayerBit = 1 << roomData.currentPlayerIndex;
                    const newDrawMask = (roomData.drawMask || 0) | currentPlayerBit;
                    const newPlayerIndex = (roomData.currentPlayerIndex + 1) % numPlayers;
                    
                    // (ä¿®å¤) å¿…é¡»æ˜¾ç¤ºå½“å‰ç©å®¶çš„æ—¥å¿—
                    logMsg = `${roomData.players[roomData.currentPlayerIndex].name} æ‘¸äº†ä¸€å¼ ç‰Œ ${logMsg}ã€‚`;
                    
                    // (æ–°) æ£€æŸ¥æ˜¯å¦æ‰€æœ‰äººéƒ½æ‘¸å®Œäº†
                    let allPlayersDrawn = true;
                    for(let i=0; i < numPlayers; i++) {
                        const playerBit = 1 << i;
                        if ((newDrawMask & playerBit) === 0) {
                            allPlayersDrawn = false;
                            break;
                        }
                    }
                    
                    if (allPlayersDrawn) {
                        // (æ–°) æ‘¸ç‰Œç»“æŸ, å¼€å§‹æ–°å›åˆ
                        transaction.update(roomRef, {
                            status: "playing",
                            currentPlayerIndex: roomData.players.findIndex(p => p.uid === roomData.lastPlayerId), // å›åˆ°æœ€åå‡ºç‰Œè€…
                            isNewRound: true, // (æ–°)
                            currentPlay: null,
                            playerPlays: {}, 
                            drawPile: newDrawPile,
                            discardPile: newDiscardPile,
                            players: updatedPlayers,
                            drawMask: newDrawMask,
                            log: arrayUnion(logMsg + " æ‘¸ç‰Œç»“æŸï¼Œæ–°å›åˆå¼€å§‹ã€‚")
                        });
                    } else {
                        // (æ–°) è½®åˆ°ä¸‹å®¶æ‘¸ç‰Œ
                        transaction.update(roomRef, {
                            currentPlayerIndex: newPlayerIndex,
                            drawPile: newDrawPile,
                            discardPile: newDiscardPile,
                            players: updatedPlayers,
                            drawMask: newDrawMask,
                            log: arrayUnion(logMsg)
                        });
                    }
                });
                
            } catch (error) {
                 console.error("Draw Error:", error);
                 drawButton.disabled = false;
            }
        };
        
        // --- 9. ç‰Œå‹éªŒè¯ (å«æ‰€æœ‰ç™å­) ---
        
        function getCardFromValue(value) {
            if (value === LAIZI_2_VALUE) return { suit: 'â™ ', rank: '2', value: 15 };
            if (value === SMALL_JOKER_VALUE) return { suit: 'Joker', rank: 'Small', value: 16 };
            if (value === BIG_JOKER_VALUE) return { suit: 'Joker', rank: 'Big', value: 17 };
            const rank = RANKS.find(r => RANK_VALUES[r] === value);
            // (ä¿®å¤) ç™å­ç‰Œæ²¡æœ‰å¸¸è§„èŠ±è‰², é»˜è®¤ç»™ä¸€ä¸ª
            return { suit: 'â™¦', rank: rank, value: value }; 
        }
        
        function getPlayDescription(playInfo) {
            if (!playInfo || !playInfo.type) return "æ— æ•ˆ";
            
            const cards = playInfo.cards || [];
            const displayCards = getDisplayCards(cards, playInfo);
            const firstCard = displayCards[0] || {};
            
            switch(playInfo.type) {
                case PLAY_TYPE.ROCKET: return "ç‹ç‚¸";
                case PLAY_TYPE.BOMB: return `ç‚¸å¼¹ ${firstCard.rank || ''}`;
                case PLAY_TYPE.SINGLE: return `å•å¼  ${firstCard.rank || ''}`;
                case PLAY_TYPE.PAIR: return `å¯¹å­ ${firstCard.rank || ''}`;
                case PLAY_TYPE.TRIO: return `ä¸‰æ¡ ${firstCard.rank || ''}`;
                case PLAY_TYPE.FULL_HOUSE: 
                    const trioRank = getCardFromValue(playInfo.value).rank;
                    const pairRank = displayCards.find(c => c.value !== playInfo.value)?.rank || 'X';
                    return `ä¸‰å¸¦äºŒ ${trioRank}${trioRank}${trioRank} + ${pairRank}${pairRank}`;
                case PLAY_TYPE.STRAIGHT:
                    const endCard = displayCards[displayCards.length - 1] || {};
                    return `é¡ºå­ ${firstCard.rank} ... ${endCard.rank}`;
                case PLAY_TYPE.CONSECUTIVE_PAIRS:
                    const endPairCard = displayCards[displayCards.length - 1] || {};
                    return `è¿å¯¹ ${firstCard.rank}${firstCard.rank} ... ${endPairCard.rank}${endPairCard.rank}`;
                default: return "å‡ºç‰Œ";
            }
        }
        
        function getDisplayCards(playedCards, playInfo) {
            if (playInfo.type === PLAY_TYPE.INVALID) return playedCards;
            if (playInfo.type === PLAY_TYPE.ROCKET) return playedCards;
            
            if (playInfo.type === PLAY_TYPE.SINGLE) {
                if (playInfo.cards[0].value !== playInfo.value) {
                    const fakeCard = getCardFromValue(playInfo.value);
                    return [{ ...fakeCard, isLaiziSub: true }];
                }
                return playedCards; 
            }

            const regulars = playedCards.filter(c => !LAIZI_VALUES.includes(c.value));
            let display = [];
            
            switch (playInfo.type) {
                case PLAY_TYPE.PAIR:
                case PLAY_TYPE.TRIO:
                case PLAY_TYPE.BOMB:
                    display = [...regulars];
                    while (display.length < playInfo.length) {
                        const fakeCard = getCardFromValue(playInfo.value);
                        display.push({ ...fakeCard, isLaiziSub: true });
                    }
                    return display;
                
                case PLAY_TYPE.STRAIGHT:
                    const startVal = playInfo.value;
                    for (let i = 0; i < playInfo.length; i++) {
                        const val = startVal + i;
                        const regCard = regulars.find(c => c.value === val);
                        if (regCard) {
                            display.push(regCard);
                        } else {
                            const fakeCard = getCardFromValue(val);
                            display.push({ ...fakeCard, isLaiziSub: true });
                        }
                    }
                    return display;
                
                case PLAY_TYPE.CONSECUTIVE_PAIRS:
                    const startValPairs = playInfo.value;
                    for (let i = 0; i < playInfo.length / 2; i++) {
                        const val = startValPairs + i;
                        const regCards = regulars.filter(c => c.value === val);
                        if (regCards.length === 2) {
                            display.push(...regCards);
                        } else if (regCards.length === 1) {
                            display.push(regCards[0]);
                            display.push({ ...getCardFromValue(val), isLaiziSub: true });
                        } else {
                            display.push({ ...getCardFromValue(val), isLaiziSub: true });
                            display.push({ ...getCardFromValue(val), isLaiziSub: true });
                        }
                    }
                    return display;

                case PLAY_TYPE.FULL_HOUSE:
                    const trioVal = playInfo.value;
                    const regularsTrio = regulars.filter(c => c.value === trioVal);
                    const regularsPairCards = regulars.filter(c => c.value !== trioVal);
                    
                    display = [...regularsTrio];
                    while (display.length < 3) {
                        display.push({ ...getCardFromValue(trioVal), isLaiziSub: true });
                    }
                    
                    if (regularsPairCards.length === 2) {
                        display.push(...regularsPairCards);
                    } else if (regularsPairCards.length === 1) {
                        display.push(regularsPairCards[0]);
                        display.push({ ...getCardFromValue(regularsPairCards[0].value), isLaiziSub: true });
                    } else { 
                        const pairVal = (regulars.length > 0 && regulars[0].value !== trioVal) ? regulars[0].value : (trioVal === 3 ? 4 : 3);
                        display.push({ ...getCardFromValue(pairVal), isLaiziSub: true });
                        display.push({ ...getCardFromValue(pairVal), isLaiziSub: true });
                    }
                    return display;
            }
            return playedCards; 
        }


        function findAllPossiblePlays(cards) {
            if (!cards || cards.length === 0) return [];

            const len = cards.length;
            const sortedCards = [...cards].sort((a, b) => a.value - b.value);

            if (len === 2 && 
                sortedCards[0].value === SMALL_JOKER_VALUE && 
                sortedCards[1].value === BIG_JOKER_VALUE) {
                return [{ type: PLAY_TYPE.ROCKET, value: 999, cards: sortedCards, length: 2 }];
            }
            
            const laizi = sortedCards.filter(c => LAIZI_VALUES.includes(c.value));
            const regulars = sortedCards.filter(c => !LAIZI_VALUES.includes(c.value));
            const laiziCount = laizi.length;
            
            let possiblePlays = [];

            if (len === 1) {
                possiblePlays.push({ type: PLAY_TYPE.SINGLE, value: sortedCards[0].value, cards: sortedCards, length: 1 });
            }
            
            if (len === 2) {
                const pair = findPair(regulars, laiziCount);
                if (pair) possiblePlays.push({ type: PLAY_TYPE.PAIR, value: pair.value, cards: sortedCards, length: 2 });
            }
            
            if (len === 3) {
                const trio = findTrio(regulars, laiziCount);
                if (trio) possiblePlays.push({ type: PLAY_TYPE.TRIO, value: trio.value, cards: sortedCards, length: 3 });
                
                const straights = findAllStraights(regulars, laiziCount, len);
                straights.forEach(s => possiblePlays.push({ type: PLAY_TYPE.STRAIGHT, value: s.value, cards: sortedCards, length: len }));
            }
            
            if (len === 4) {
                const bomb = findBomb(regulars, laiziCount);
                if (bomb) possiblePlays.push({ type: PLAY_TYPE.BOMB, value: bomb.value, cards: sortedCards, length: 4 });
                
                const straights = findAllStraights(regulars, laiziCount, len);
                straights.forEach(s => possiblePlays.push({ type: PLAY_TYPE.STRAIGHT, value: s.value, cards: sortedCards, length: len }));
                
                const consPairs = findAllConsecutivePairs(regulars, laiziCount, len);
                consPairs.forEach(cp => possiblePlays.push({ type: PLAY_TYPE.CONSECUTIVE_PAIRS, value: cp.value, cards: sortedCards, length: len }));
            }
            
            if (len === 5) {
                const fullHouse = findFullHouse(regulars, laiziCount);
                if (fullHouse) possiblePlays.push({ type: PLAY_TYPE.FULL_HOUSE, value: fullHouse.value, cards: sortedCards, length: 5 });
                
                const straights = findAllStraights(regulars, laiziCount, len);
                straights.forEach(s => possiblePlays.push({ type: PLAY_TYPE.STRAIGHT, value: s.value, cards: sortedCards, length: len }));
            }
            
            if (len > 5) {
                 if (len % 2 === 0) {
                     const consPairs = findAllConsecutivePairs(regulars, laiziCount, len);
                     consPairs.forEach(cp => possiblePlays.push({ type: PLAY_TYPE.CONSECUTIVE_PAIRS, value: cp.value, cards: sortedCards, length: len }));
                 }
                 const straights = findAllStraights(regulars, laiziCount, len);
                 straights.forEach(s => possiblePlays.push({ type: PLAY_TYPE.STRAIGHT, value: s.value, cards: sortedCards, length: len }));
            }

            return possiblePlays;
        }
        
        function getPlayType(cards) {
             const plays = findAllPossiblePlays(cards);
             return plays.length > 0 ? plays[0] : { type: PLAY_TYPE.INVALID };
        }
        
        function findBomb(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 4) return null;
            if (regulars.length === 0) return { value: 3 }; 

            const valueCounts = {};
            regulars.forEach(c => { valueCounts[c.value] = (valueCounts[c.value] || 0) + 1; });
            
            for (const value of Object.keys(valueCounts).map(Number).sort((a,b) => a-b)) {
                if (valueCounts[value] + laiziCount >= 4) {
                    return { value: value };
                }
            }
            
            if (regulars.length === 0) {
                 return { value: 3 }; // (æ–°) 4 ç™å­, é»˜è®¤å½“ 3333
            }
            
            return null; 
        }

        function findFullHouse(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 5) return null;
            if (regulars.length <= 1) return { value: 3 }; 

            const valueCounts = {};
            regulars.forEach(c => { valueCounts[c.value] = (valueCounts[c.value] || 0) + 1; });
            const uniqueValues = Object.keys(valueCounts).map(Number);
            
            if (uniqueValues.length === 1) { 
                return { value: uniqueValues[0] };
            }
            
            if (uniqueValues.length === 2) {
                const val1 = uniqueValues[0];
                const count1 = valueCounts[val1];
                const val2 = uniqueValues[1];
                const count2 = valueCounts[val2];
                
                let neededForTrio = 3 - count1;
                let neededForPair = 2 - count2;
                if (neededForTrio >= 0 && neededForPair >= 0 && neededForTrio + neededForPair <= laiziCount) {
                    return { value: val1 };
                }
                
                neededForTrio = 3 - count2;
                neededForPair = 2 - count1;
                if (neededForTrio >= 0 && neededForPair >= 0 && neededForTrio + neededForPair <= laiziCount) {
                    return { value: val2 };
                }
            }
            return null;
        }
        
        function findAllStraights(regulars, laiziCount, totalLength) {
            let possibleStraights = [];
            if (regulars.length === 0 && laiziCount >= totalLength) {
                 possibleStraights.push({ value: 3 }); 
                 return possibleStraights;
            }
            
            const uniqueValues = [...new Set(regulars.map(c => c.value))];
            uniqueValues.sort((a, b) => a - b);
            
            if (uniqueValues.some(v => v >= LAIZI_2_VALUE)) return []; 
            
            const minReg = uniqueValues.length > 0 ? uniqueValues[0] : LAIZI_2_VALUE;
            
            const maxPossibleStart = minReg;
            const minPossibleStart = Math.max(3, minReg - laiziCount); 

            for (let startVal = minPossibleStart; startVal <= maxPossibleStart; startVal++) {
                const endVal = startVal + totalLength - 1;
                if (endVal >= LAIZI_2_VALUE) continue; 

                let needed = 0;
                for (let v = startVal; v <= endVal; v++) {
                    if (!uniqueValues.includes(v)) {
                        needed++;
                    }
                }
                
                if (needed <= laiziCount) {
                    possibleStraights.push({ value: startVal }); 
                }
            }
            
            return possibleStraights; 
        }
        
        function findAllConsecutivePairs(regulars, laiziCount, totalLength) {
            let possiblePairs = [];
            const numPairs = totalLength / 2;
            if (numPairs < 2 || totalLength % 2 !== 0) return [];
            
            if (regulars.length === 0 && laiziCount >= totalLength) {
                possiblePairs.push({ value: 3 });
                return possiblePairs;
            }

            const valueCounts = {};
            regulars.forEach(c => { valueCounts[c.value] = (valueCounts[c.value] || 0) + 1; });
            
            if (regulars.some(c => c.value >= LAIZI_2_VALUE)) return []; 
            
            const uniqueValues = [...new Set(regulars.map(c => c.value))].sort((a, b) => a - b);
            const minReg = uniqueValues.length > 0 ? uniqueValues[0] : LAIZI_2_VALUE;

            // (æ–°) 4422 -> 3344 (startVal=3) or 4455 (startVal=4)
            // (æ–°) è¿­ä»£æ‰€æœ‰å¯èƒ½çš„èµ·å§‹ç‚¹
            let maxPossibleStart = minReg;
            if (uniqueValues.length > 0) {
                 // 4422, minReg=4, laizi=2, numPairs=2. maxStart=4
                 // minStart=max(3, 4 - 2) = 3
                 // è¿­ä»£ 3, 4
                 maxPossibleStart = minReg;
                 
                 // å¦‚æœå…¨æ˜¯ç™å­, maxPossibleStart = 3
                 // å¦‚æœæœ‰ 44, laizi=2, total=4. maxStart=4. minStart=max(3, 4-2) = 3
                 // 
                 const maxReg = uniqueValues[uniqueValues.length - 1];
                 const minPossibleEnd = maxReg; // æœ€å°çš„ç»ˆç‚¹
                 const maxPossibleStartFromEnd = minPossibleEnd - numPairs + 1;
                 maxPossibleStart = Math.max(minReg, maxPossibleStartFromEnd + laiziCount);
            }
            const minPossibleStart = Math.max(3, minReg - laiziCount); 

            for (let startVal = minPossibleStart; startVal <= maxPossibleStart; startVal++) {
                const endVal = startVal + numPairs - 1;
                if (endVal >= LAIZI_2_VALUE) continue; 

                let needed = 0;
                for (let v = startVal; v <= endVal; v++) {
                    const countInRegs = valueCounts[v] || 0;
                    needed += Math.max(0, 2 - countInRegs);
                }
                
                if (needed <= laiziCount) {
                    possiblePairs.push({ value: startVal }); 
                }
            }
            return possiblePairs; 
        }

        function findTrio(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 3) return null;
            if (regulars.length === 0) return { value: 3 }; 
            
            const firstVal = regulars[0].value;
            if (regulars.every(c => c.value === firstVal)) {
                return { value: firstVal };
            }
            return null;
        }

        function findPair(regulars, laiziCount) {
            if (regulars.length + laiziCount !== 2) return null;
            if (regulars.length === 0) return { value: 3 }; 
            
            const firstVal = regulars[0].value;
            if (regulars.every(c => c.value === firstVal)) {
                return { value: firstVal };
            }
            return null;
        }


        function isValidPlay(playInfo, lastPlay, isNewRound) {
            if (playInfo.type === PLAY_TYPE.INVALID) return false;
            
            if (isNewRound || !lastPlay) return true;

            if (playInfo.type === PLAY_TYPE.ROCKET) return true; 
            if (lastPlay.type === PLAY_TYPE.ROCKET) return false; 

            if (playInfo.type === PLAY_TYPE.BOMB) {
                if (lastPlay.type === PLAY_TYPE.BOMB) {
                    return playInfo.value === lastPlay.value + 1;
                }
                return true; 
            }
            
            if (lastPlay.type === PLAY_TYPE.BOMB) {
                return false; 
            }
            
            if (playInfo.type === PLAY_TYPE.SINGLE &&
                LAIZI_VALUES.includes(playInfo.value) &&
                lastPlay.type === PLAY_TYPE.SINGLE &&
                lastPlay.value < BIG_JOKER_VALUE)
            {
                // (æ–°) ç™å­ä¸èƒ½ä»£æ›¿ç™å­
                if (LAIZI_VALUES.includes(lastPlay.value + 1)) {
                    return false;
                }
                return true;
            }

            if (playInfo.type === PLAY_TYPE.CONSECUTIVE_PAIRS) {
                if (lastPlay.type !== PLAY_TYPE.CONSECUTIVE_PAIRS) return false;
                if (playInfo.length !== lastPlay.length) return false;
                if (lastPlay.value === 14 && playInfo.value === 15) return false; // (æ–°) è¿å¯¹ä¸èƒ½åˆ°2
                return playInfo.value === lastPlay.value + 1;
            }
            if (lastPlay.type === PLAY_TYPE.CONSECUTIVE_PAIRS) return false; 

            if (playInfo.type !== lastPlay.type) return false;
            if (playInfo.type === PLAY_TYPE.STRAIGHT && playInfo.length !== lastPlay.length) return false;
            
            if (lastPlay.value === BIG_JOKER_VALUE) { 
                return false; 
            }
            
            // (æ–°) A(14) -> 2(15) -> S.Joker(16) -> B.Joker(17)
            if (playInfo.type === PLAY_TYPE.PAIR) {
                 if (lastPlay.value === 14 && playInfo.value === 15) return true; // AA -> 22
                 if (lastPlay.value === 15 && playInfo.value === 16) return true; // 22 -> å°ç‹å¯¹
                 if (lastPlay.value === 16 && playInfo.value === 17) return true; // å°ç‹å¯¹ -> å¤§ç‹å¯¹
            }
            if (playInfo.type === PLAY_TYPE.SINGLE) {
                 if (lastPlay.value === 14 && playInfo.value === 15) return true; // A -> 2
                 if (lastPlay.value === 15 && playInfo.value === 16) return true; // 2 -> å°ç‹
                 if (lastPlay.value === 16 && playInfo.value === 17) return true; // å°ç‹ -> å¤§ç‹
            }
            
            return playInfo.value === lastPlay.value + 1;
        }

        // --- å¯åŠ¨ ---
        initFirebase();

    </script>
</body>
</html>
